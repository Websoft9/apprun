---
stepsCompleted: [1, 2, 3, 4, 6]
inputDocuments: 
  - "docs/analysis/product-brief-apprun-2025-12-12.md"
documentCounts:
  briefs: 1
  research: 0
  brainstorming: 0
  projectDocs: 0
workflowType: 'prd'
lastStep: 6
project_name: 'apprun'
user_name: 'Root'
date: '2025-12-18'
---

# Product Requirements Document - apprun

**Author:** Root
**Date:** 2025-12-18

## 执行摘要

### 产品愿景

**apprun** 是一个企业级的 Backend as a Service (BaaS) 平台，为企业产品开发提供统一的技术基础设施框架。通过集成认证、权限、数据模型、函数计算、工作流引擎（Temporal）、事件中心、国际化、存储、实时推送、API 网关和监控等核心模块，让开发团队专注于业务逻辑创新，而非重复实现基础设施。

**核心目标：** 减少 90% 的基础开发工作，将产品上市周期从 6 个月缩短到 2 个月。

### 核心问题

企业产品开发中，开发团队面临以下痛点：

- **重复劳动**：每个项目都要重新实现认证、权限、数据模型等通用模块
- **事件驱动复杂**：组件间事件传递、异步任务管理需要大量胶水代码
- **实时需求困难**：手写 WebSocket 逻辑，处理连接管理和状态同步
- **微服务集成繁琐**：服务间调用、路由转发缺乏统一管理
- **问题排查低效**：日志分散在各个服务，难以追踪和定位问题
- **质量不一致**：不同项目的基础实现存在差异，技术债务积累

### 解决方案

apprun 提供轻量级、模块化的 BaaS 平台，采用 **Go 语言构建**，包含以下核心模块：

#### 核心服务容器（合并部署）
这些服务在生产环境中作为单个容器运行，开发环境支持单镜像部署：

1. **🔐 认证与权限**
   - 统一的用户管理和访问控制（JWT + RBAC）
   - 企业级安全标准支持
   - 与 API 网关深度集成

2. **🚪 API 网关**
   - 统一微服务入口和路由转发
   - 集成认证授权
   - 基础路由和代理功能
   - *注：MVP 不包含限流、服务发现、熔断降级、灰度发布*

3. **📊 数据模型**
   - 可视化数据建模和自动 API 生成
   - 基于 PostgREST 或自建 ORM
   - 支持快速原型开发

4. **📡 实时数据推送**
   - WebSocket 服务端主动推送能力
   - 支持实时数据同步（数据变更 → 客户端更新）
   - 典型场景：持续部署状态推送、任务进度更新
   - *注：MVP 不包含房间/频道、消息持久化、送达确认*
   - *技术选型待架构阶段确定*

#### 独立服务容器

5. **🔄 工作流引擎（Temporal）**
   - **可靠的工作流编排**：处理复杂业务流程和长时间运行任务
   - 与事件中心集成：事件中心触发工作流，工作流发布事件
   - 支持事件驱动、定时触发、手工执行
   - **插件化节点架构**：SMTP、HTTP、数据库等节点可扩展
   - **用户自定义节点**：支持调用自己的微服务
   - 内置重试、补偿、状态管理机制
   - 基于 YAML/代码配置（不提供可视化设计器）
   - *注：工作流的业务编排能力不在 apprun 范围内，属于独立项目*

5b. **🔔 事件中心（Event Hub）**
   - 基于 NATS 的轻量级事件总线
   - **高性能事件流**：处理高并发、低延迟的事件传递
   - **发布-订阅模式**：模块间解耦通信
   - **与 Temporal 协同**：快速路由事件，触发工作流执行
   - 支持实时推送的事件源
   - 独立部署容器（与 Temporal 协同）
   - *注：作为 Temporal 的高性能补充，不替代工作流编排*

6. **⚡ 函数服务**
   - 无服务器函数执行环境
   - 基于 Docker/Containerd 或 WASM 运行时
   - 支持业务逻辑快速部署

7. **💾 存储服务**
   - 文件和对象存储解决方案
   - *注：MinIO 已停止开源，需选择轻量级替代方案或自研*

8. **🌍 国际化(i18n)**
   - 多语言内容管理和本地化
   - 支持全球化产品开发

9. **📊 日志与监控**
   - 集中式日志收集和查询
   - 性能指标监控
   - 分布式追踪
   - 告警规则配置

10. **🔔 事件中心（Event Hub）**
   - 轻量级高性能事件总线（基于 NATS）
   - 发布-订阅模式和点对点消息
   - 与 Temporal 协同工作
   - 支持模块间异步解耦通信
   - 为实时推送提供事件流基础
   - *注：作为 Temporal 的补充，处理高并发事件流*
   - *技术选型：NATS（Go 原生，轻量级）*

### 核心差异化

**轻量级部署优先**
- **开发环境**：单容器镜像，多服务进程，快速启动
- **生产环境**：核心服务合并容器（认证+权限+网关+数据+实时推送）+ 独立容器（工作流+函数+存储+i18n+监控）
- Go 语言单二进制编译，资源占用低
- 配置文件驱动的模块化启用
- 明确排除重量级方案（Supabase/Appwrite）

**事件驱动架构**
- **工作流引擎（Temporal）**：可靠的业务流程编排和长时间任务
- **事件中心（NATS）**：高性能事件路由和模块解耦通信
- 明确分工：Temporal 处理可靠性和状态管理，Event Hub 处理高吞吐事件流
- 插件化节点设计，用户可扩展自定义节点
- 支持事件驱动、定时任务、手工触发

**实时推送能力**
- 服务端主动推送（部署状态、任务进度）
- WebSocket 连接管理和状态同步
- 专注实时数据推送，不追求完整的即时通讯功能

**开发体验优先**
- 一行配置启用核心功能
- 自动 API 生成减少 CRUD 开发
- 统一认证授权，无需重复实现

**可观测性内置**
- 集中式日志查询，问题定位从小时级到分钟级
- 实时性能监控和告警
- 分布式追踪支持

### 目标用户

**主要用户：开发者**（如李明）
- 减少 90% 基础设施开发时间
- 专注业务逻辑创新
- 快速原型验证

**次要用户：架构师**（如王晓）
- 标准化架构，技术一致性
- 事件驱动架构统一管理
- 实时监控系统健康状况

**次要用户：产品经理**（如张丽）
- 产品上市周期从 6 个月缩短到 2 个月
- 迭代频率提升 3 倍
- 快速响应市场需求

### 成功指标

**3 个月目标：**
- 至少 3 个团队采用，开发效率提升 50%+
- 用户满意度评分 4.0/5

**12 个月目标：**
- 覆盖企业 80% 的产品项目
- 累计节省开发时间 1000+ 人天
- ROI 达到 300%

## 项目分类

**技术类型：** API Backend + Developer Platform
- BaaS 后端平台
- 开发者基础设施工具

**技术栈：** Go 语言 + Temporal 工作流引擎

**领域：** Developer Tools / Enterprise Infrastructure

**复杂度：** Medium-High
- 9 大核心模块集成
- 事件驱动架构
- 企业级安全和可扩展性
- 采用轻量级策略控制复杂度

**项目上下文：** Greenfield（绿地项目）

## 技术约束与决策

**已确定：**
- ✅ 编程语言：Go
- ✅ 工作流引擎：Temporal
- ✅ 部署模式：开发单镜像，生产核心合并+独立容器
- ✅ 工作流节点：插件化架构，支持用户扩展
- ❌ 不包含：工作流可视化设计器、业务编排能力

**待架构阶段明确：**
- ⏳ 平台事件总线与 Temporal 的集成模式
- ⏳ 实时推送技术选型（自建 vs 集成第三方）
- ⏳ 数据模型方案（PostgREST vs 自建）
- ⏳ 存储服务方案（MinIO 替代方案）
- ⏳ 函数运行时选择（Docker/Containerd vs WASM）

**明确不实现（MVP）：**
- ❌ 实时推送的房间/频道、消息持久化、送达确认
- ❌ API 网关的限流、服务发现、熔断降级、灰度发布
- ❌ 工作流的可视化设计器和业务编排能力

## 事件驱动架构设计原则

### 核心架构：Temporal + Event Hub 双引擎

apprun 采用 **Temporal 工作流引擎** 和 **Event Hub 事件中心** 双引擎协同的事件驱动架构，明确分工、各司其职。

#### **Temporal 工作流引擎**

**适用场景：**
- ✅ **可靠的业务流程编排**：多步骤、有状态的复杂工作流
- ✅ **长时间运行任务**：天/周/月级别的持久化任务
- ✅ **需要可靠性保证**：自动重试、补偿、状态恢复
- ✅ **事务性操作**：需要完整的执行历史和审计追踪

**不适用场景：**
- ❌ 高吞吐事件流处理（设计目标不是消息队列）
- ❌ 多对多事件广播（需要手动实现扇出）
- ❌ 毫秒级实时事件传递（相对延迟较高）
- ❌ 动态订阅关系（工作流启动时订阅已确定）

**Temporal 存储机制：**
- ✅ 存储工作流事件历史（WorkflowStarted, ActivityCompleted 等）
- ✅ 支持故障恢复和事件重放
- ✅ 支持 Signal 机制（类似点对点消息）
- ❌ 不支持传统的发布-订阅广播模式

#### **Event Hub 事件中心**

**适用场景：**
- ✅ **高性能事件流**：处理高并发、低延迟的事件传递
- ✅ **发布-订阅模式**：多对多事件广播和解耦通信
- ✅ **实时事件路由**：模块间异步通信的"高速公路"
- ✅ **动态订阅**：运行时添加/删除订阅者

**不适用场景：**
- ❌ 需要同步返回结果的场景（使用直接 RPC 调用）
- ❌ 事务性操作需要立即确认的场景
- ❌ 复杂的多步骤业务流程编排（使用 Temporal）

**设计模式：Fire-and-Forget（发布即忘）**

事件中心采用标准的发布-订阅模式，发布者发布事件后立即返回，不等待订阅者处理结果。

### 发布者职责

**应该做的：**
- ✅ 发布事件到事件中心
- ✅ 处理发布失败（网络错误、队列满等）
- ✅ 携带必要的事件元数据（event_id, timestamp, correlation_id）

**不应该做的：**
- ❌ 等待订阅者处理结果
- ❌ 关心有多少订阅者
- ❌ 假设订阅者一定会处理成功

**示例代码：**
```go
// 发布事件并立即返回
err := eventHub.Publish("user.registered", UserEvent{
    EventID:       uuid.New(),
    UserID:        user.ID,
    Email:         user.Email,
    Timestamp:     time.Now(),
    CorrelationID: ctx.RequestID(),
})
if err != nil {
    // 只处理发布失败（网络错误、队列满等）
    log.Error("Failed to publish event", err)
    return err
}
// 事件已接收，发布者继续执行
log.Info("Event published successfully")
```

### 订阅者职责

**应该做的：**
- ✅ 异步处理接收到的事件
- ✅ 自行处理失败重试和错误记录
- ✅ 实现幂等性（同一事件可能收到多次）
- ✅ 可以发布新事件通知处理结果（可选）

**不应该做的：**
- ❌ 依赖同步响应给发布者
- ❌ 假设事件处理一定成功
- ❌ 阻塞事件处理流程

**示例代码：**
```go
// 订阅者：异步处理事件
eventHub.Subscribe("user.registered", func(event UserEvent) {
    err := sendWelcomeEmail(event.Email)
    if err != nil {
        // 订阅者自己处理失败（重试、记录日志、告警）
        log.Error("Failed to send welcome email", err)
        
        // 可选：发布失败事件到死信队列
        eventHub.Publish("user.email.failed", FailedEvent{
            OriginalEvent:  event,
            ErrorMessage:   err.Error(),
            RetryCount:     3,
            CorrelationID:  event.CorrelationID,
        })
    } else {
        // 可选：发布成功事件
        eventHub.Publish("user.email.sent", EmailSentEvent{
            UserID:        event.UserID,
            Email:         event.Email,
            CorrelationID: event.CorrelationID,
        })
    }
})
```

### 结果反馈机制（可选）

如果发布者需要知道处理结果，可采用 **"回调事件模式"**：

**双向事件流：**
1. 发布者发布事件（带 `correlation_id`）
2. 订阅者处理并发布结果事件（成功/失败）
3. 发布者订阅结果事件，通过 `correlation_id` 匹配

**优势：**
- ✅ 保持异步解耦
- ✅ 发布者可以选择是否关心结果
- ✅ 不阻塞发布者继续执行

**示例场景：**
```
1. 认证模块 → Event Hub 发布 "user.registered" (correlation_id: abc-123)

2. 邮件服务 → Event Hub 发布 "user.email.sent" (correlation_id: abc-123)
   或
   邮件服务 → Event Hub 发布 "user.email.failed" (correlation_id: abc-123)

3. 认证模块订阅 "user.email.sent" 和 "user.email.failed"
   根据 correlation_id 匹配原始请求
```

### 何时不使用事件中心

以下场景不应该使用事件中心，应该使用直接调用：

- ❌ **需要同步返回结果**：API 网关调用验证服务
- ❌ **事务性操作需要立即确认**：支付处理
- ❌ **请求-响应模式的 API 调用**：数据查询

**反模式示例：**
```go
// ❌ 错误：将事件中心当作 RPC 使用
result := eventHub.PublishAndWait("validate.request", request) // 不要这样做

// ✅ 正确：直接调用
result := validationService.Validate(request)
```

### Temporal 与 Event Hub 协同

**典型集成模式：**

**模式 1：Event Hub 触发 Temporal 工作流**
```
业务模块 → Event Hub 发布 "order.created"
           ↓
        Temporal 订阅 → 启动订单处理工作流
           ↓
        工作流编排：库存扣减 → 支付 → 物流 → 通知
```

**模式 2：Temporal 发布事件到 Event Hub**
```
Temporal 工作流执行中
  ↓
发布中间状态事件 → Event Hub
  ↓
多个订阅者接收：
  - 实时推送模块 → WebSocket 推送到前端
  - 统计服务 → 更新指标
  - 审计服务 → 记录日志
```

**模式 3：混合流程**
```
用户注册 → Event Hub 发布 "user.registered"
  ↓
订阅者们并行处理：
  - Temporal 工作流（发送欢迎邮件 + 创建用户资料）
  - 统计服务（更新注册指标）
  - 积分服务（后续动态添加）
```

### 性能特性与保证

**Event Hub 性能指标：**
- ✅ **事件发布延迟**：< 5ms（P95）
- ✅ **端到端延迟**：< 50ms（P95，发布到订阅者接收）
- ✅ **吞吐量**：≥ 10000 消息/秒
- ✅ **可靠性**：至少一次交付（at-least-once delivery）

**Temporal 性能指标：**
- ✅ **工作流启动延迟**：< 1 秒
- ✅ **事件持久化**：100%（所有工作流事件历史）
- ✅ **故障恢复**：自动从历史重放
- ✅ **可靠性**：至少一次执行（at-least-once execution）

### 最佳实践

**事件命名规范：**
```
<资源>.<动作>.<状态>

示例：
- user.registered          （用户注册完成）
- user.email.sent          （邮件发送成功）
- user.email.failed        （邮件发送失败）
- deployment.status.update （部署状态更新）
- order.created            （订单创建）
- order.payment.completed  （订单支付完成）
```

**事件数据结构：**
```go
type Event struct {
    EventID       string    `json:"event_id"`       // 唯一事件 ID
    EventType     string    `json:"event_type"`     // 事件类型
    Timestamp     time.Time `json:"timestamp"`      // 时间戳
    CorrelationID string    `json:"correlation_id"` // 关联 ID（可选）
    Source        string    `json:"source"`         // 事件源
    Data          any       `json:"data"`           // 事件数据
}
```

**幂等性设计：**
```go
// 订阅者应该实现幂等性
func handleUserRegistered(event UserEvent) {
    // 检查是否已处理过此事件
    if alreadyProcessed(event.EventID) {
        log.Info("Event already processed, skipping")
        return
    }
    
    // 处理事件
    processEvent(event)
    
    // 标记为已处理
    markAsProcessed(event.EventID)
}
```

**错误处理策略：**
```go
// 重试策略
type RetryPolicy struct {
    MaxRetries    int           // 最大重试次数
    InitialDelay  time.Duration // 初始延迟
    MaxDelay      time.Duration // 最大延迟
    BackoffFactor float64       // 退避因子
}

// 死信队列
if retryCount > maxRetries {
    eventHub.Publish("dlq.failed_events", FailedEvent{
        OriginalEvent: event,
        Error:         err.Error(),
        RetryCount:    retryCount,
    })
}
```

### 技术选型说明

**Event Hub 技术选型：NATS**

选择理由：
- ✅ Go 原生实现，与 apprun 技术栈一致
- ✅ 轻量级部署，资源占用低
- ✅ 高性能（支持百万级消息/秒）
- ✅ 内置发布-订阅、点对点、请求-响应模式
- ✅ 简单易用，学习曲线低

替代方案对比：
- **Kafka**：过于重量级，不符合 apprun 轻量化原则
- **RabbitMQ**：部署复杂，资源占用较高
- **Redis Streams**：功能有限，可靠性保证较弱

## 成功标准

### 用户成功

#### 魔力时刻（Aha Moments）

**开发者的顿悟时刻：**

1. **部署即可用** - 启动 apprun 后立即访问自动生成的 API
   - 无需编写任何 CRUD 代码
   - 数据模型配置即生成完整的 RESTful API
   - 从安装到第一个 API 调用成功 < 5 分钟

2. **配置驱动开发** - 通过配置而非编码实现功能
   - 定义数据模型 → 自动生成 CRUD API
   - 配置认证方式 → 多种认证策略开箱即用
   - 指定 API 路径 → WebSocket 实时推送自动启用

3. **实时状态可见** - 第一次看到实时推送的部署状态
   - 持续部署进度实时更新到前端
   - 无需手写 WebSocket 逻辑
   - 连接管理和状态同步自动处理

#### 典型成功场景

**场景 1：服务器管理功能开发**

传统方式需要：
- 编写服务器数据模型（Entity/DTO）
- 实现 CRUD 接口（Create/Read/Update/Delete）
- 编写路由和控制器
- 实现认证和权限检查
- 测试所有 API 端点
- **预计时间：2-3 天**

使用 apprun：
- 配置服务器数据模型（YAML/可视化）
- API 自动生成并可访问
- 认证和权限自动集成
- （可选）指定 API 路径启用 WebSocket 实时推送
- **实际时间：1-2 小时**
- **时间节省：95%+**

**场景 2：实时数据推送**

传统方式需要：
- 实现 WebSocket 服务端逻辑
- 处理客户端连接管理
- 实现断线重连机制
- 设计消息推送协议
- **预计时间：1-2 周**

使用 apprun：
- 指定 API 路径启用 WebSocket
- 配置推送事件源
- 客户端自动接收实时更新
- **实际时间：< 1 天**
- **时间节省：90%+**

#### 可衡量的用户成功指标

**开发者李明视角：**
- ✅ **项目启动时间**：从需求到第一个可用原型 < 1 天（传统 1 周）
- ✅ **编码时间减少**：CRUD 功能从 2-3 天缩短到 1-2 小时（95% 时间节省）
- ✅ **代码质量提升**：基础设施相关 bug 减少 90%
- ✅ **专注业务逻辑**：每周节省 3-5 天基础设施开发时间
- ✅ **实时功能交付**：从 2 周缩短到 1 天（90% 时间节省）
- ✅ **问题排查效率**：集中式日志，从小时级缩短到分钟级
- ✅ **创新能力提升**：每月尝试的新业务功能数量增加 2 倍

**架构师王晓视角：**
- ✅ **架构一致性**：跨项目组件接口一致性 95%
- ✅ **扩展性**：新微服务集成从 2 周缩短到 2 天
- ✅ **技术债务**：基础设施重构需求减少 80%
- ✅ **系统稳定性**：生产环境故障率降低 50%
- ✅ **可观测性**：MTTR（平均恢复时间）降低 70%
- ✅ **事件驱动统一**：基于 Temporal 的统一事件总线

**产品经理张丽视角：**
- ✅ **上市时间**：产品发布周期从 6 个月缩短到 2 个月（67% 时间节省）
- ✅ **迭代频率**：每月发布新版本的能力提升 3 倍
- ✅ **用户满意度**：产品发布后用户满意度评分 4.5/5
- ✅ **市场响应**：新功能上线后 1 个月内用户采用率 70%

### 业务成功

#### 短期目标（3 个月）

**采用率指标：**
- ✅ 至少 3 个内部团队采用 apprun 作为开发平台
- ✅ 每个团队报告开发效率提升 50% 以上
- ✅ 至少 1 个完整的业务流程投入生产（涉及所有 10 大核心模块）

**满意度指标：**
- ✅ 用户满意度调查平均评分 4.0/5
- ✅ 至少 80% 的开发者表示愿意推荐给其他团队
- ✅ 收集到 50+ 有效的功能需求反馈

**技术验证：**
- ✅ MVP 所有核心模块验证可用
- ✅ 完成至少 2 个典型业务场景的端到端测试
- ✅ 轻量级部署目标达成（见技术成功标准）

#### 中期目标（12 个月）

**规模化采用：**
- ✅ 覆盖企业 80% 的产品项目（基于 apprun 开发）
- ✅ 累计节省开发时间 1000+ 人天
- ✅ 支持 10+ 个生产环境业务系统

**投资回报：**
- ✅ ROI（投资回报率）达到 300%
- ✅ 平台开发和维护成本 < 节省的人力成本的 30%
- ✅ 减少外部 SaaS 服务依赖，降低运营成本

**技术成熟度：**
- ✅ 生产环境稳定运行 6+ 个月
- ✅ 建立完整的文档和最佳实践库
- ✅ 形成内部社区和技术支持体系

#### 长期愿景（1-2 年）

**平台生态：**
- 成为企业数字化转型的核心平台
- 培养创新文化，员工专注于高价值工作
- 建立插件市场和开发者生态

### 技术成功

#### MVP 阶段技术验证目标

**功能完整性：**
- ✅ 完成一个端到端的业务流程，涉及所有 10 大核心模块：
  1. 认证与权限 - 用户登录和访问控制
  2. API 网关 - 统一入口和路由
  3. 数据模型 - 自动 CRUD API 生成
  4. 实时推送 - WebSocket 状态更新
  5. 工作流引擎 - 事件驱动任务编排
  6. 函数服务 - 自定义业务逻辑
  7. 存储服务 - 文件上传和访问
  8. 国际化 - 多语言支持
  9. 日志与监控 - 集中式可观测性
  10. 事件中心 - 高性能事件路由和解耦通信

**轻量级部署目标：**
- ✅ **内存占用** ≤ 1GB（核心服务容器 + 必要依赖）
- ✅ **启动时间** ≤ 20 秒（从容器启动到服务可用）
- ✅ **镜像大小** ≤ 500MB（开发环境单镜像）
- ✅ **最小依赖**：PostgreSQL + 可选存储组件

**性能基准（正常标准）：**
- ✅ **API 响应时间**：P95 < 200ms（简单查询）
- ✅ **并发处理**：单实例支持 1000+ 并发请求
- ✅ **WebSocket 连接**：单实例支持 5000+ 并发连接
- ✅ **工作流执行**：事件触发到执行延迟 < 1 秒
- ✅ **事件吞吐量**：≥ 10000 消息/秒（Event Hub）
- ✅ **事件延迟**：P95 < 50ms（发布到订阅接收）

**稳定性基准（正常标准）：**
- ✅ **可用性**：开发环境 95%+，生产环境 99%+
- ✅ **错误率**：< 0.1%（系统错误，非业务逻辑错误）
- ✅ **数据一致性**：事务完整性保证，无数据丢失
- ✅ **自动恢复**：服务崩溃后自动重启和恢复

**可扩展性验证：**
- ✅ 支持水平扩展（多实例部署）
- ✅ 支持模块化启用/禁用（按需加载）
- ✅ 支持插件化节点扩展（工作流自定义节点）
- ✅ 支持多租户隔离（数据和权限）

**开发体验验证：**
- ✅ 配置驱动：数据模型配置即生成 API（零代码）
- ✅ 快速启动：从安装到第一个 API 调用 < 5 分钟
- ✅ 简化配置：核心功能通过配置文件启用
- ✅ 完整文档：覆盖所有核心模块的使用指南

### 可衡量的里程碑

#### Phase 1: MVP 交付（前 3 个月）

**Month 1：核心模块验证**
- Week 1-2：认证、权限、API 网关基础功能
- Week 3-4：数据模型和自动 API 生成

**Month 2：集成与扩展**
- Week 5-6：工作流引擎（Temporal）集成和事件驱动
- Week 7-8：实时推送、函数服务、存储服务

**Month 3：完善与上线**
- Week 9-10：国际化、日志监控完善
- Week 11：端到端业务流程验证
- Week 12：第一个内部团队试用和反馈

**关键里程碑检查点：**
- ✅ 技术可行性验证（所有模块可用）
- ✅ 轻量级目标达成（内存 ≤ 1GB，启动 ≤ 20s）
- ✅ 典型场景验证（服务器管理 + 实时推送）
- ✅ 至少 1 个团队采用并给出正面反馈

#### Phase 2: 生产就绪（3-6 个月）

- 性能优化和压力测试
- 生产环境部署和监控
- 完整的文档和培训材料
- 3 个团队正式采用

#### Phase 3: 规模化推广（6-12 个月）

- 高级功能迭代（基于用户反馈）
- 插件市场和生态建设
- 覆盖 80% 企业项目
- ROI 300% 达成

## 产品范围

### MVP - 最小可行产品

**必须包含（所有 10 大核心模块）：**

1. **认证与权限**
   - JWT + RBAC 基础实现
   - 与 API 网关集成
   - 支持基础用户管理

2. **API 网关**
   - 统一入口和路由转发
   - 认证集成
   - 基础代理功能

3. **数据模型**
   - 配置化数据模型定义
   - 自动 CRUD API 生成
   - PostgreSQL 集成

4. **实时推送**
   - WebSocket 服务端推送
   - 基础连接管理
   - 指定路径启用推送
   - 与事件中心集成（接收事件源）

5. **工作流引擎（Temporal）**
   - 事件驱动、定时触发、手工执行
   - 基础节点（HTTP、SMTP、数据库）
   - 插件化架构支持用户自定义节点
   - 与事件中心集成（监听事件、发布事件）

6. **函数服务**
   - 基础函数运行时
   - 支持 Go 函数部署
   - 与工作流集成

7. **存储服务**
   - 基础文件上传和访问
   - 轻量级存储方案（MinIO 替代品或自研）

8. **国际化(i18n)**
   - 基础多语言配置
   - 内容管理和切换

9. **日志与监控**
   - 集中式日志收集
   - 基础性能指标监控
   - 简单告警配置

10. **事件中心（Event Hub）**
    - 基于 NATS 的轻量级事件总线
    - 发布-订阅基础实现
    - 与 Temporal 和实时推送的集成点
    - 模块间解耦通信

**MVP 成功标准：**
- ✅ 完整端到端业务流程验证
- ✅ 轻量级部署目标达成
- ✅ 典型场景时间节省 90%+
- ✅ 至少 1 个团队生产使用

### 增长功能（MVP 后 3-6 个月）

**性能与规模化：**
- 高级性能优化和缓存策略
- 水平扩展和负载均衡
- 高可用和灾备机制

**开发体验增强：**
- CLI 工具和脚手架
- 可视化数据模型设计器
- 更丰富的工作流节点库

**企业级功能：**
- 多租户管理和隔离
- 高级 RBAC 和细粒度权限
- 审计日志和合规支持

### 未来愿景（6-12 个月）

**高级功能：**
- API 网关的限流、熔断、灰度发布
- 实时推送的房间/频道、消息持久化
- 工作流可视化监控和调试
- AI 驱动的日志异常检测

**生态建设：**
- 插件市场和社区
- SDK 和集成库
- 第三方服务集成

**平台化：**
- 低代码开发能力
- 服务网格集成
- 智能化运维（AIOps）

## 用户旅程

### 旅程 1：李明 - 从基础设施苦力到业务创新者

李明是一位经验丰富的后端开发者，已经在企业工作了 5 年。每次接到新项目，他都要花费大量时间重复实现相同的功能：用户认证、权限管理、数据库 CRUD、文件上传等。最让他沮丧的是，每周都有 3-5 天时间被这些"重复劳动"占据，真正用于创新业务逻辑的时间少之又少。

**转折点来了。** 某个周一早晨，技术总监在团队会议上宣布引入 apprun 作为新的开发平台。李明心想："又是一个新工具，又要学习新的东西。"但他还是决定试一试。

**第一次接触 apprun：** 李明接到一个任务——为公司的运维系统增加服务器管理功能。传统方式下，他需要：
1. 设计服务器数据模型（字段、关系、验证规则）
2. 编写 Entity 类和 DTO 对象
3. 实现 CRUD 接口（Create/Read/Update/Delete）
4. 编写路由和控制器
5. 实现认证和权限检查
6. 编写单元测试
7. 调试和优化

**预计时间：2-3 天。**

但使用 apprun 后，李明打开配置文件，用 YAML 格式定义了服务器数据模型：

```yaml
models:
  Server:
    fields:
      name: string
      ip_address: string
      status: enum[active, inactive, maintenance]
      created_at: timestamp
    auth: jwt
    permissions: rbac
```

**保存配置，重启 apprun。5 分钟后，API 就自动生成了！**

李明难以置信地测试了一下：
- `GET /api/servers` - 查询所有服务器
- `POST /api/servers` - 创建新服务器
- `PUT /api/servers/:id` - 更新服务器
- `DELETE /api/servers/:id` - 删除服务器

**认证和权限自动集成，数据验证自动处理。** 李明的第一反应是："这不可能这么简单吧？"

**魔力时刻：** 当他第一次成功调用自动生成的 API 时，李明意识到："原来开发可以这么快！"这 2-3 天的工作量，在 apprun 中只需要 1-2 小时的配置时间。**时间节省 95%！**

**更大的突破：** 李明后来需要实现实时部署状态推送功能。传统方式下，他需要手写 WebSocket 服务端逻辑、处理连接管理、实现断线重连机制——预计需要 1-2 周。但在 apprun 中，他只需要在配置文件中指定一个 API 路径启用 WebSocket：

```yaml
realtime:
  paths:
    - /api/deployments/status
```

**< 1 天完成！** 客户端自动接收实时更新，连接管理和状态同步完全自动化。

**六个月后：** 李明已经交付了 8 个新功能模块，是以前的 3 倍速度。他每周节省的 3-5 天时间，全部用于探索新技术和优化业务逻辑。团队评审会上，他提出的创新方案数量是以前的 2 倍。李明不再是"基础设施苦力"，而是真正的"业务创新者"。

---

### 旅程 2：王晓 - 从技术债务危机到架构掌控者

王晓是公司的企业架构师，负责确保所有项目的技术标准和架构一致性。但过去两年，他陷入了一个噩梦：公司快速扩张，10 个产品项目各自为政，每个团队都用不同的方式实现认证、数据访问、微服务通信。技术债务像滚雪球一样累积，系统整体健康状况难以评估。

**危机爆发：** 一次生产环境故障，因为日志分散在各个服务，王晓花了整整 4 小时才定位到问题根源。更糟糕的是，当他想统一微服务架构时，发现每个项目的 API 网关、认证方式、监控方案都不一样，迁移成本巨大。

**apprun 带来的转机：** 技术总监决定引入 apprun 作为统一开发平台。王晓一开始持怀疑态度："又一个'银弹'方案吗？"但当他深入研究 apprun 的架构设计后，眼前一亮：

1. **统一的 API 网关** - 所有微服务的入口和路由标准化
2. **基于 Temporal 的事件总线** - 统一的事件驱动架构
3. **集中式日志与监控** - 所有服务的可观测性统一管理
4. **标准化认证授权** - JWT + RBAC 跨项目一致

**第一个试点项目：** 王晓选择了一个中型项目作为 apprun 试点。他最担心的问题是："现有微服务如何迁移？"但 apprun 的设计让他惊喜：

- 旧服务可以通过 API 网关逐步接入，无需一次性重写
- 工作流引擎的插件化节点支持调用现有微服务
- 渐进式迁移，风险可控

**魔力时刻：** 两周后，试点项目成功部署。王晓打开 apprun 的监控 dashboard，实时看到：
- 所有微服务的健康状况
- API 响应时间、错误率、吞吐量
- 集中式日志查询，支持分布式追踪

**问题排查从小时级缩短到分钟级。** 当再次发生生产故障时，王晓通过集中式日志，5 分钟就定位到问题并解决。MTTR（平均恢复时间）降低了 70%！

**一年后：** 公司 80% 的项目已经基于 apprun 开发，技术架构高度一致。新微服务集成从 2 周缩短到 2 天，架构一致性达到 95%。王晓不再疲于救火，而是专注于战略设计和技术创新。

---

### 旅程 3：张丽 - 从项目延误到快速迭代女王

张丽是一位敏捷产品经理，管理着 3 个并行产品线。她最大的痛苦是产品上市周期长达 6 个月，等功能开发完成时，市场需求已经变化。竞争对手总能更快推出新功能，让她感到无力。

**最糟糕的一次：** 一个重要的客户功能需求，张丽的团队花了 4 个月开发，最终上线时客户说："我们已经用竞争对手的产品了，这个功能对我们已经不重要了。"张丽沮丧极了。

**apprun 改变游戏规则：** 当技术团队开始使用 apprun 后，张丽注意到开发速度明显提升。李明告诉她："张经理，我现在每周能完成的功能是以前的 3 倍。"

**第一次快速迭代体验：** 张丽接到一个紧急需求——为企业客户增加多租户管理功能。传统方式下，这需要：
- 2 周需求分析
- 4 周开发（认证、权限、数据隔离）
- 2 周测试
- **总计 8 周（2 个月）**

但基于 apprun：
- 1 周需求分析（不变）
- **1 周开发**（数据模型配置 + apprun 自动多租户隔离）
- 1 周测试
- **总计 3 周！**

**魔力时刻：** 当张丽在第 3 周的演示会上向客户展示新功能时，客户惊讶地说："你们这么快就做出来了？我以为至少需要 2 个月！"张丽第一次感受到"快速响应市场"的快感。

**六个月后：** 张丽的产品迭代频率从每季度 1 次提升到每月 2-3 次。用户满意度从 3.2/5 提升到 4.5/5。更重要的是，张丽的产品线在市场竞争中开始占据主动，而不是被动追赶。产品上市周期从 6 个月缩短到 2 个月，ROI 达到 300%。

---

### 旅程 4：陈强（平台管理员）- 掌控 apprun 平台的守护者

陈强是公司新招的平台管理员，负责管理 apprun 平台本身。他的主要职责包括：配置核心服务、监控系统健康、管理租户和权限、处理平台级故障。

**入职第一天：** 陈强有些紧张，毕竟 apprun 支撑着公司 80% 的产品开发。技术总监告诉他："apprun 设计很简洁，你很快就能上手。"

**第一个任务：为新项目创建租户**

传统方式下，陈强需要：
1. 手动创建数据库 schema
2. 配置独立的认证规则
3. 设置权限隔离
4. 配置监控和日志

但在 apprun 中，陈强打开管理控制台，点击"创建租户"：

```yaml
tenant:
  name: "新产品线"
  plan: pro
  resources:
    max_users: 100
    max_storage: 10GB
```

**5 分钟完成！** apprun 自动创建了独立的数据空间、配置了认证和权限隔离、启用了监控。

**魔力时刻：** 某天凌晨 3 点，apprun 的告警系统通知陈强："核心服务容器内存使用率 85%"。陈强打开监控 dashboard，立即看到：
- 实时内存占用趋势
- CPU 使用率历史曲线
- 慢查询日志

他快速定位到问题：某个租户的数据查询效率低下。陈强通过管理控制台临时限制了该租户的资源配额，然后联系开发团队优化查询。**整个过程 15 分钟，系统未发生故障。**

**三个月后：** 陈强管理着 15 个租户、100+ 开发者。apprun 的轻量级设计让他可以轻松扩展和维护。系统可用性保持在 99.5% 以上。

---

### 旅程 5：赵敏（运维工程师）- 从半夜救火到自动化守护

赵敏是公司的运维工程师，负责部署和维护所有生产环境服务。在使用 apprun 之前，她的生活充满了半夜被叫醒、紧急修复故障、手动部署更新的噩梦。

**最糟糕的一次：** 凌晨 2 点，生产环境崩溃。赵敏被电话叫醒，远程登录服务器，发现日志分散在 8 个不同的服务中。她花了整整 3 小时才定位到问题，然后手动重启服务。第二天上班时，赵敏已经 24 小时没合眼。

**apprun 的救赎：** 公司引入 apprun 后，赵敏的第一反应是："又要学习新的部署方式吗？"但当她看到 apprun 的部署文档时，眼前一亮：

**开发环境部署：**
```bash
docker run -d apprun/apprun:latest
```
**一个镜像，20 秒启动，内存占用 < 1GB。**

**生产环境部署：**
```yaml
# docker-compose.yml
services:
  apprun-core:
    image: apprun/core:latest
    environment:
      - MODULES=auth,gateway,data,realtime
  temporal:
    image: temporalio/temporal:latest
  postgres:
    image: postgres:14
```

**魔力时刻：** 第一次使用 apprun 部署新服务时，赵敏惊讶地发现：
- 启动时间 < 20 秒
- 内存占用 < 1GB
- 集中式日志自动收集
- 健康检查和自动重启内置

更重要的是，当某个服务崩溃时，apprun 会自动重启并恢复，无需赵敏半夜起床。

**六个月后：** 赵敏的半夜紧急电话从每月 5-6 次降低到每月 0-1 次。系统可用性从 95% 提升到 99%+。赵敏终于可以安心睡觉了。

---

### 旅程 6：刘洋（API 集成开发者）- 轻松集成的第三方开发者

刘洋是一家合作伙伴公司的开发者，需要将他们的 SaaS 产品与客户公司的 apprun 平台集成。他过去集成过很多企业系统，每次都是噩梦：文档不全、API 不一致、认证复杂。

**第一次接触 apprun API：** 刘洋打开 apprun 的 API 文档，惊喜地发现：
- 标准的 RESTful API 设计
- 完整的 OpenAPI 规范文档
- 清晰的认证说明（JWT）
- 丰富的代码示例

**第一个 API 调用：**
```bash
# 获取 JWT Token
curl -X POST https://api.example.com/auth/login \
  -d '{"email": "developer@partner.com", "password": "xxx"}'

# 调用数据 API
curl -X GET https://api.example.com/api/servers \
  -H "Authorization: Bearer <token>"
```

**成功！** 刘洋花了不到 1 小时就完成了第一个集成测试。

**更强大的功能：** 刘洋需要实时接收客户系统的部署状态更新。apprun 的实时推送 API 让这变得简单：

```javascript
const ws = new WebSocket('wss://api.example.com/api/deployments/status');
ws.onmessage = (event) => {
  const status = JSON.parse(event.data);
  console.log('部署状态:', status);
};
```

**连接管理和断线重连自动处理。** 刘洋不需要编写复杂的重连逻辑。

**两周后：** 刘洋完成了完整的集成，比预期提前了 1 周。客户对集成质量非常满意，续约了 3 年合作。

---

### 旅程 7：孙薇（技术支持工程师）- 快速排查问题的侦探

孙薇是技术支持团队的工程师，每天接到大量用户的问题报告。在使用 apprun 之前，她排查问题的流程是：

1. 收集用户描述
2. 联系开发团队获取日志访问权限
3. 在多个服务的日志中搜索相关信息
4. 拼凑完整的错误链路
5. 向开发团队反馈

**预计时间：2-4 小时，甚至更长。**

**某天，一个紧急问题：** 用户报告"服务器创建失败，但不知道原因"。以前，孙薇需要联系开发团队，等待他们查看日志。

但现在，孙薇打开 apprun 的支持控制台：

**集中式日志查询：**
```
搜索：user_id=12345 AND action=create_server AND timestamp>now-1h
```

**1 秒内找到相关日志：**
```
[ERROR] 2025-12-18 10:23:45 - Server creation failed
[CAUSE] Insufficient storage quota for tenant
[TRACE] Request ID: abc-123-xyz
```

**魔力时刻：** 孙薇立即看到了完整的错误链路，包括：
- 用户操作时间
- 失败原因（存储配额不足）
- 请求追踪 ID
- 相关的所有微服务调用记录

孙薇回复用户："您的账户存储配额已满，请升级套餐或清理旧文件。"

**问题排查从 2-4 小时缩短到 5 分钟！**

**三个月后：** 孙薇的平均问题解决时间从 3 小时降低到 30 分钟。用户满意度从 3.5/5 提升到 4.7/5。更重要的是，孙薇现在可以独立解决 80% 的问题，无需频繁打扰开发团队。

---

### 旅程需求总结

这些用户旅程揭示了 apprun 需要的核心能力：

#### 开发者旅程（李明）揭示需求：
- 配置驱动的数据模型定义
- 自动 CRUD API 生成
- 一键启用实时推送
- 认证和权限自动集成
- 零代码实现基础功能

#### 架构师旅程（王晓）揭示需求：
- 统一的 API 网关和路由管理
- 基于 Temporal 的事件驱动架构
- 集中式日志和分布式追踪
- 实时监控 dashboard
- 渐进式迁移支持

#### 产品经理旅程（张丽）揭示需求：
- 快速原型开发能力
- 多租户管理功能
- 配置化功能启用
- 版本迭代和发布管理

#### 平台管理员旅程（陈强）揭示需求：
- 租户管理控制台
- 资源配额和隔离
- 系统健康监控
- 告警和通知机制

#### 运维工程师旅程（赵敏）揭示需求：
- 轻量级部署（单镜像/Docker Compose）
- 快速启动（≤ 20 秒）
- 低资源占用（≤ 1GB）
- 自动健康检查和重启
- 集中式日志收集

#### API 集成开发者旅程（刘洋）揭示需求：
- 标准 REST API 设计
- 完整的 API 文档（OpenAPI）
- 简单的 JWT 认证
- WebSocket 实时推送 API
- 丰富的代码示例

#### 技术支持旅程（孙薇）揭示需求：
- 集中式日志查询界面
- 分布式追踪和请求 ID
- 支持人员访问控制
- 快速错误定位工具
- 用户操作审计日志

## 创新与新颖模式

### 核心创新理念

**apprun 的本质：配置即开发（Configuration as Development）**

apprun 不是传统的 BaaS 平台，而是一个**微服务组合的开发框架**，通过多种 DSL/YAML 驱动开发，将"写代码"转变为"写配置"。这个理念颠覆了传统的开发范式，让开发者专注于"描述需求"而非"实现细节"。

### 创新领域 1：轻量级架构突破

#### 技术挑战

如何在 1GB 内存和 20 秒启动时间内，集成 10 个核心模块？这是 BaaS 平台的技术天花板。

#### 创新解决方案

**1. 轻量级组件选型**
- **策略**：优先选择轻量级组件或包
- **案例**：
  - 事件中心选择 NATS（Go 原生）而非 Kafka（JVM 重量级）
  - 工作流引擎选择 Temporal（可嵌入）而非独立服务网格
  - 存储服务排除 MinIO（已闭源且重），寻找轻量级替代

**2. Go 单二进制 + 多进程复用**
- **策略**：单一容器内运行多进程，共享资源
- **技术手段**：
  - Go 编译为单二进制文件，无外部依赖
  - 核心服务（认证+网关+数据+实时推送）合并为单进程
  - 进程间通过本地 IPC 通信，减少网络开销
  - 多进程部署在单一容器内，共享内存和文件系统

**3. 模块按需加载**
- **策略**：配置文件驱动的模块化启用
- **实现**：
  ```yaml
  # apprun.yml
  modules:
    enabled:
      - auth        # 必须
      - gateway     # 必须
      - data        # 按需
      - realtime    # 按需
      - workflow    # 按需
  ```
- **效果**：只加载业务需要的模块，进一步降低资源占用

#### 市场对比

| 维度 | Supabase | Appwrite | apprun |
|------|----------|----------|--------|
| **内存占用** | 2-4GB | 1.5-3GB | ≤ 1GB |
| **启动时间** | 60-120s | 45-90s | ≤ 20s |
| **容器数量** | 8-12 个 | 6-10 个 | 1-3 个 |
| **语言栈** | JS/TS/Rust | PHP/Node | 纯 Go |
| **定位** | 重量级全栈 | 中量级全栈 | 轻量级框架 |

**创新价值**：apprun 突破了"功能完整性"与"资源占用"的矛盾，证明企业级 BaaS 可以做到极致轻量。

---

### 创新领域 2：执行与指令解耦架构

#### 洞察来源

**发现**：单一事件总线（Kafka/RabbitMQ）只能发布事件，没有能力处理长时间运行的任务。

**问题场景**：
- 用户注册后需要发送欢迎邮件（可能重试多次）
- 订单创建后需要执行：库存扣减 → 支付 → 物流 → 通知（多步骤、有状态）
- 部署任务启动后需要持续推送状态更新（长时间运行）

**传统方案的不足**：
- **仅用事件总线**：无法保证执行可靠性，状态管理困难
- **仅用工作流引擎**：高并发事件处理性能瓶颈，无法实时广播

#### 创新解决方案：双引擎协同架构

**核心洞察：将执行与指令解耦**

```
指令层（Event Hub - NATS）
  ↓ 快速路由、广播、解耦
  ↓
执行层（Temporal）
  ↓ 可靠编排、状态管理、长时间运行
  ↓
结果反馈（Event Hub）
```

**分工明确**：
- **Event Hub（NATS）**：处理"指令传递"
  - 高性能（10K+ msg/s）
  - 低延迟（< 50ms P95）
  - 动态订阅
  - 发布-订阅广播

- **Temporal**：处理"可靠执行"
  - 长时间运行任务（天/周/月级别）
  - 自动重试和补偿
  - 状态持久化和恢复
  - 执行历史审计

**创新价值**：
- ✅ 解决了事件总线的执行可靠性问题
- ✅ 解决了工作流引擎的高并发性能问题
- ✅ 两者协同，各司其职，优势互补

**业界对比**：
- **AWS Step Functions + SNS/SQS**：类似思路但重量级，需多个独立服务
- **Azure Logic Apps + Event Grid**：云厂商方案，无法轻量化部署
- **apprun Temporal + NATS**：开源组合，单容器部署，轻量级

---

### 创新领域 3：配置即开发范式

#### 市场空白分析

**为什么企业不用现有方案？**

| 方案 | 问题 | apprun 优势 |
|------|------|------------|
| **Supabase/Appwrite** | 太重：多容器、高资源占用 | 单容器 1GB，20s 启动 |
| **自建脚手架** | 功能太少：缺乏集成和标准化 | 10 大模块集成，配置即开发 |
| **Spring Boot/Django** | 仍需写大量代码 | YAML 配置自动生成 API |
| **低代码平台** | 灵活性差，企业级功能不足 | 代码与配置混合，可扩展 |

#### apprun 的独特价值主张

**定位：配置驱动的微服务组合框架**

**核心能力**：
1. **多 DSL 驱动开发**
   ```yaml
   # 数据模型 DSL
   models:
     Server:
       fields: { name: string, ip: string }
       auth: jwt
   
   # 实时推送 DSL
   realtime:
     paths: [/api/servers]
   
   # 工作流 DSL
   workflows:
     - name: onboarding
       trigger: event.user.registered
       steps: [sendEmail, createProfile]
   ```

2. **配置 = 代码的等价性**
   - 传统开发：写 Entity → Controller → Service → Test（2-3 天）
   - apprun 开发：写 YAML 配置（1-2 小时）
   - 结果：完全等价的 API 功能

3. **渐进式复杂度**
   - **简单场景**：纯配置（CRUD、认证、推送）
   - **中等场景**：配置 + 工作流节点
   - **复杂场景**：配置 + 自定义函数 + 微服务集成

**创新价值**：
- ✅ 不是"低代码"（限制灵活性），而是"配置即代码"（保持灵活性）
- ✅ 不是"脚手架"（生成后分离），而是"运行时框架"（持续驱动）
- ✅ 不是"重量级平台"（独立部署），而是"嵌入式框架"（与业务共存）

---

### 创新领域 4：企业级轻量化平衡

#### 市场定位创新

**apprun 的"甜蜜点"**：

```
轻量级 ←------------------------→ 企业级
   
简单脚手架              apprun              Supabase
   ↓                      ↓                    ↓
功能少              10 大模块集成           功能全面
快速启动            1GB/20s 启动            资源密集
缺乏标准             标准化框架            标准化平台
无集成              完整集成                完整集成
```

**创新突破**：
- 传统认知：企业级 = 重量级 = 高资源占用
- apprun 证明：企业级功能可以通过轻量级架构实现

**技术手段**：
1. **Go 语言单栈**：无多语言运行时开销
2. **进程合并**：减少容器间通信
3. **按需加载**：不用的模块不加载
4. **轻量级组件**：NATS vs Kafka，PostgREST vs ORM
5. **配置驱动**：减少代码量和依赖

---

### 验证策略与风险缓解

#### MVP 验证计划（3 个月）

**注意**：创新假设的验证无法预知完整结果，但可以设计渐进式验证路径。

**Week 1-4：轻量级架构验证**
- ✅ 单容器集成 10 大模块
- ✅ 内存占用 ≤ 1GB 测试
- ✅ 启动时间 ≤ 20s 测试
- **风险**：资源占用超标 → 缓解：模块按需加载降级

**Week 5-8：双引擎协同验证**
- ✅ Temporal + NATS 集成测试
- ✅ 事件流性能测试（10K msg/s）
- ✅ 工作流可靠性测试（重试、补偿）
- **风险**：性能不达标 → 缓解：独立容器部署降级

**Week 9-12：配置即开发验证**
- ✅ 典型场景时间对比（CRUD 开发）
- ✅ 3 个试点团队反馈
- ✅ 开发效率提升量化（目标 50%+）
- **风险**：学习曲线过高 → 缓解：完善文档和示例

#### 创新风险与降级方案

**风险 1：轻量级目标无法达成**
- **降级方案**：拆分为多容器部署（类似 Supabase）
- **底线**：功能完整性优先于轻量化

**风险 2：双引擎复杂度过高**
- **降级方案**：简化为单一 Temporal，牺牲部分性能
- **底线**：工作流可靠性是核心价值

**风险 3：配置 DSL 表达能力不足**
- **降级方案**：支持自定义函数和微服务扩展
- **底线**：保持渐进式复杂度设计

---

### 市场竞争力分析

#### 差异化矩阵

| 维度 | Supabase | Appwrite | Spring Boot | apprun |
|------|----------|----------|-------------|--------|
| **部署复杂度** | 高（多容器） | 中（多容器） | 低（单 JAR） | **极低（单容器）** |
| **资源占用** | 重（2-4GB） | 中（1.5-3GB） | 中（512MB-1GB） | **轻（≤ 1GB）** |
| **功能完整性** | 全面 | 全面 | 需自建 | **全面且集成** |
| **开发范式** | SQL + JS | 控制台 + SDK | 代码 | **配置即开发** |
| **事件驱动** | 部分支持 | 基础支持 | 需自建 | **双引擎架构** |
| **企业级特性** | ✅ | ✅ | ✅ | ✅ |
| **学习曲线** | 中 | 低 | 高 | **中（配置为主）** |

**竞争优势**：
1. ✅ 唯一同时满足"轻量级"和"企业级"的 BaaS 框架
2. ✅ 唯一采用"配置即开发"范式的微服务框架
3. ✅ 唯一实现"双引擎协同"的事件驱动架构

#### 目标市场

**最适合 apprun 的场景**：
- 🎯 企业内部产品快速开发（80% 覆盖率目标）
- 🎯 中小型 SaaS 产品 MVP 验证
- 🎯 微服务架构标准化改造
- 🎯 现有系统的事件驱动升级

**不适合的场景**：
- ❌ 超大规模互联网应用（需专门优化）
- ❌ 极致性能要求场景（需裸金属优化）
- ❌ 完全低代码无代码需求（apprun 是框架不是平台）

---

### 创新总结

apprun 的创新不是单点突破，而是**系统性创新**：

1. **架构创新**：双引擎协同（执行与指令解耦）
2. **范式创新**：配置即开发（DSL 驱动）
3. **工程创新**：轻量级企业级（打破传统认知）
4. **定位创新**：微服务组合框架（填补市场空白）

这些创新共同构成了 apprun 的**不可替代性**，让它在 BaaS 市场中开辟了独特的赛道。

---

## 架构决策记录（Architecture Decision Records）

> **方法说明**：通过多位架构师的辩论和权衡分析，显性展示关键架构决策的深层逻辑。

### ADR-001：单容器 vs 微服务架构

#### 决策上下文

apprun 需要在开发环境提供极简部署体验，同时在生产环境支持水平扩展和高可用。

#### 参与架构师

**架构师 A（性能优化派）- 李云**
- **立场**：支持单容器部署
- **论据**：
  1. 进程间通信通过本地 IPC，零网络延迟
  2. 共享内存访问，减少数据序列化开销
  3. 简化部署配置，降低运维复杂度
  4. Go 单二进制编译，启动速度 < 20s
- **权衡认知**：牺牲了模块独立扩展能力

**架构师 B（云原生派）- 王浩**
- **立场**：主张完全微服务化
- **论据**：
  1. 每个模块独立扩展（如工作流引擎可独立扩容）
  2. 故障隔离更彻底（一个模块崩溃不影响其他）
  3. 技术栈更灵活（不同模块可用不同语言）
  4. 符合 Kubernetes 云原生最佳实践
- **权衡认知**：增加部署复杂度和资源占用

**架构师 C（务实平衡派）- 赵敏**
- **立场**：混合架构（核心合并 + 重服务独立）
- **论据**：
  1. 开发环境单容器，降低入门门槛
  2. 生产环境核心服务合并，重服务独立部署
  3. 核心服务（认证+网关+数据）耦合度高，合并收益大
  4. 重服务（Temporal+函数+存储）独立部署，灵活扩展
- **权衡认知**：增加部署配置复杂度，但最大化实用价值

#### 最终决策

**选择：混合架构（架构师 C 方案）**

**决策理由**：
1. **开发体验优先**：单容器部署让新用户 5 分钟上手
2. **生产灵活性**：核心合并容器 + 5 个独立容器的混合部署
3. **资源优化**：核心服务合并后内存占用 < 500MB
4. **扩展能力**：工作流引擎和函数服务可独立水平扩展

**权衡接受**：
- ✅ 接受：部署配置复杂度从"单一模式"增加到"两种模式"
- ✅ 接受：核心服务需要共同重启（但重启时间 < 20s）
- ❌ 拒绝：完全微服务化带来的 8-12 个容器管理成本

**验证指标**：
- 开发环境启动时间 ≤ 20s
- 核心合并容器内存 ≤ 500MB
- 生产环境总容器数 ≤ 6 个（1 核心 + 5 独立）

---

### ADR-002：Temporal + NATS 双引擎 vs 单一事件总线

#### 决策上下文

apprun 需要支持事件驱动架构，但面临性能与可靠性的双重挑战。

#### 参与架构师

**架构师 A（极简派）- 刘洋**
- **立场**：只用 NATS 事件总线
- **论据**：
  1. 架构极简，学习曲线低
  2. NATS 本身支持重试和持久化
  3. 减少一个核心依赖（Temporal）
  4. 部署和维护成本更低
- **权衡认知**：长时间运行任务和复杂工作流需要自行实现

**架构师 B（可靠性派）- 孙薇**
- **立场**：只用 Temporal 工作流引擎
- **论据**：
  1. Temporal 自带事件存储和状态管理
  2. 工作流可视化和调试能力强
  3. 内置重试、补偿、Saga 模式
  4. 企业级成熟度高（Uber/Netflix 验证）
- **权衡认知**：高并发事件广播性能瓶颈

**架构师 C（分层派）- 陈强**
- **立场**：双引擎协同（NATS 指令层 + Temporal 执行层）
- **论据**：
  1. **指令与执行分离**：NATS 处理高并发事件流，Temporal 处理可靠工作流
  2. **性能与可靠性兼得**：NATS 10K+ msg/s，Temporal 保证零丢失
  3. **灵活组合**：简单事件用 NATS，复杂流程用 Temporal
  4. **业界验证**：类似 AWS Step Functions + SNS/SQS 的思路
- **权衡认知**：架构复杂度增加，需要明确的使用场景指导

#### 最终决策

**选择：双引擎协同（架构师 C 方案）**

**决策理由**：
1. **核心洞察**："将执行与指令解耦" - 单一组件无法同时优化性能和可靠性
2. **性能验证**：NATS 事件延迟 < 50ms，Temporal 无法达到此性能
3. **可靠性验证**：Temporal 工作流零丢失，NATS 需要额外实现
4. **场景互补**：
   - 模块间通信（高频低重要性）→ NATS
   - 业务流程编排（低频高重要性）→ Temporal
   - 实时推送事件源 → NATS
   - 长时间运行任务 → Temporal

**权衡接受**：
- ✅ 接受：架构复杂度增加，需要设计原则文档（已完成）
- ✅ 接受：两个组件的学习成本
- ✅ 接受：集成和调试的额外工作
- ❌ 拒绝：性能瓶颈（单一 Temporal）或可靠性风险（单一 NATS）

**验证指标**：
- NATS 事件吞吐量 ≥ 10K msg/s
- NATS 事件延迟 P95 < 50ms
- Temporal 工作流执行成功率 > 99.9%
- 典型业务场景端到端延迟 < 100ms

**风险缓解**：
- **降级路径 1**：如果集成复杂度过高，简化为单一 Temporal（牺牲性能）
- **降级路径 2**：如果 NATS 可靠性不足，全部迁移到 Temporal（牺牲吞吐量）

---

### ADR-003：配置 DSL vs 低代码可视化

#### 决策上下文

apprun 的"配置即开发"理念需要选择开发者交互方式。

#### 参与架构师

**架构师 A（代码优先派）- 李明**
- **立场**：纯代码方式（类似 Spring Boot）
- **论据**：
  1. 开发者最熟悉，无学习成本
  2. IDE 支持好（智能提示、重构、调试）
  3. 版本控制和代码审查友好
  4. 灵活性最高，无表达能力限制
- **权衡认知**：开发效率提升有限，仍需写大量样板代码

**架构师 B（可视化派）- 张丽**
- **立场**：图形化低代码平台（类似 Appwrite）
- **论据**：
  1. 零代码体验，产品经理可直接配置
  2. 可视化工作流设计器，直观易懂
  3. 降低技术门槛，扩大用户群体
  4. 所见即所得，减少配置错误
- **权衡认知**：复杂场景表达能力不足，企业级功能受限

**架构师 C（DSL 平衡派）- 王晓**
- **立场**：YAML/DSL 配置 + 代码扩展
- **论据**：
  1. **YAML 配置**：简单场景（CRUD、认证）零代码
  2. **代码扩展**：复杂场景（自定义函数、微服务）完全灵活
  3. **渐进式复杂度**：从配置到代码的平滑过渡
  4. **版本控制友好**：纯文本配置文件，Git 管理
  5. **IDE 支持**：YAML Schema 提供智能提示
- **权衡认知**：需要学习 DSL 语法，但学习曲线可控

#### 最终决策

**选择：YAML DSL + 代码扩展（架构师 C 方案）**

**决策理由**：
1. **目标用户**：开发者（非业务人员），DSL 学习成本可接受
2. **核心价值**："配置即代码"而非"无代码" - 保持灵活性
3. **渐进式设计**：
   - **阶段 1**：纯 YAML 配置（90% 场景）
   - **阶段 2**：YAML + 工作流节点（95% 场景）
   - **阶段 3**：YAML + 自定义函数（99% 场景）
   - **阶段 4**：YAML + 微服务集成（100% 场景）
4. **版本控制**：纯文本配置文件，完美融入 Git 工作流

**权衡接受**：
- ✅ 接受：需要编写 YAML 配置文档和最佳实践
- ✅ 接受：DSL 语法的学习曲线（预计 1-2 小时上手）
- ✅ 接受：暂不提供可视化设计器（降低 MVP 复杂度）
- ❌ 拒绝：纯代码方式的低效率（无法达到 95% 时间节省目标）
- ❌ 拒绝：低代码平台的灵活性限制（企业级功能受限）

**配置示例**：

```yaml
# 简单场景：纯配置
models:
  Server:
    fields: { name: string, ip: string }
    auth: jwt

# 中等场景：配置 + 工作流
workflows:
  - name: onboarding
    trigger: event.user.registered
    steps:
      - sendEmail:
          template: welcome
      - createProfile:
          fields: [name, email]

# 复杂场景：配置 + 自定义函数
functions:
  - name: customValidation
    runtime: go
    source: ./functions/validation.go
    trigger:
      type: http
      path: /api/validate
```

**验证指标**：
- 典型 CRUD 场景配置时间 < 10 分钟
- 开发者学习 DSL 时间 < 2 小时
- 复杂场景代码扩展覆盖率 > 95%

---

### ADR-004：Go 单语言栈 vs 多语言微服务

#### 决策上下文

apprun 需要在语言灵活性和系统一致性之间权衡。

#### 参与架构师

**架构师 A（多语言派）- 刘洋**
- **立场**：支持多语言微服务（Go + Node + Python）
- **论据**：
  1. 不同模块选择最佳语言（如函数服务支持 Python）
  2. 吸引更多开发者（不限于 Go 开发者）
  3. 集成第三方服务更容易
  4. 灵活性最高
- **权衡认知**：运行时复杂度增加，资源占用翻倍

**架构师 B（单语言派）- 赵敏**
- **立场**：纯 Go 单语言栈
- **论据**：
  1. **轻量级目标**：单一运行时，无多语言开销
  2. **启动速度**：Go 二进制启动 < 1s，Node/Python 需 5-10s
  3. **内存占用**：Go 运行时 < 50MB，Node/Python > 100MB
  4. **维护成本**：单一工具链，依赖管理简单
  5. **性能一致性**：避免跨语言调用性能损耗
- **权衡认知**：函数服务灵活性受限（仅支持 Go）

**架构师 C（混合派）- 陈强**
- **立场**：核心 Go，函数服务支持多语言
- **论据**：
  1. apprun 核心用 Go 保证轻量级
  2. 函数服务通过容器隔离支持多语言
  3. 工作流节点可调用任意语言的微服务
  4. 平衡灵活性与性能
- **权衡认知**：函数服务需要额外的容器运行时

#### 最终决策

**选择：核心 Go + 函数服务多语言（架构师 C 方案）**

**决策理由**：
1. **轻量级优先**：apprun 核心用纯 Go 实现
   - 10 大核心模块全部 Go 开发
   - 单二进制编译，无外部运行时依赖
   - 启动时间 < 20s，内存占用 < 1GB
2. **灵活性扩展**：
   - 函数服务支持 Docker/Containerd 运行时（多语言）
   - 工作流节点可调用任意 HTTP 服务（语言无关）
   - 用户自定义节点可用任意语言开发
3. **边界清晰**：
   - apprun 平台 = 纯 Go
   - 用户业务逻辑 = 任意语言

**权衡接受**：
- ✅ 接受：apprun 核心模块仅限 Go 开发者贡献
- ✅ 接受：函数服务需要容器运行时（增加部署复杂度）
- ✅ 接受：多语言函数的启动延迟（冷启动）
- ❌ 拒绝：核心模块多语言（破坏轻量级目标）

**技术实现**：

```yaml
# apprun 核心：纯 Go
core:
  language: go
  modules: [auth, gateway, data, realtime, events, i18n, logs]

# 独立服务：可多语言但推荐 Go
services:
  temporal: go
  storage: go

# 函数服务：支持多语言
functions:
  runtimes:
    - go        # 原生支持，性能最优
    - python    # Docker 容器
    - nodejs    # Docker 容器
    - custom    # 自定义镜像
```

**验证指标**：
- apprun 核心启动时间 < 20s（纯 Go 目标）
- Go 函数冷启动 < 100ms
- Python/Node 函数冷启动 < 2s（容器启动）
- 核心模块内存占用 < 1GB（不含函数服务）

---

### ADR-005：PostgREST vs 自建 ORM

#### 决策上下文

apprun 的数据模型模块需要自动生成 CRUD API，面临技术选型决策。

#### 参与架构师

**架构师 A（PostgREST 派）- 李云**
- **立场**：集成 PostgREST 自动生成 API
- **论据**：
  1. **零代码**：数据库 schema 直接映射为 REST API
  2. **成熟稳定**：PostgREST 已被 Supabase 验证
  3. **性能优秀**：直接查询数据库，无 ORM 开销
  4. **功能丰富**：自动分页、排序、过滤、关联查询
  5. **开发速度**：无需编写 CRUD 代码
- **权衡认知**：业务逻辑扩展能力有限，依赖外部项目

**架构师 B（ORM 派）- 王浩**
- **立场**：自建 Go ORM（类似 GORM）
- **论据**：
  1. **完全控制**：自主开发，无外部依赖风险
  2. **灵活扩展**：业务逻辑、验证规则、钩子函数随意定制
  3. **性能优化**：针对 apprun 场景定制优化
  4. **版本稳定**：不受 PostgREST 版本变更影响
  5. **技术栈统一**：纯 Go 实现
- **权衡认知**：开发和维护成本高，功能成熟度需要时间

**架构师 C（混合派）- 孙薇**
- **立场**：MVP 用 PostgREST，后续可选 ORM
- **论据**：
  1. **MVP 快速验证**：PostgREST 开箱即用，加速上市
  2. **渐进式迁移**：API 层保持一致，底层实现可替换
  3. **用户选择**：配置文件指定 `dataEngine: postgrest | orm`
  4. **风险对冲**：PostgREST 失败可快速切换到 ORM
- **权衡认知**：维护两套实现增加长期成本

#### 最终决策

**选择：MVP 用 PostgREST，保留 ORM 扩展路径（架构师 C 方案）**

**决策理由**：
1. **MVP 优先**：3 个月时间紧张，PostgREST 加速开发
2. **功能验证**：PostgREST 完整功能可验证"配置即开发"价值
3. **技术风险**：PostgREST 已被 Supabase 大规模验证，成熟度高
4. **未来灵活性**：
   - Phase 1（MVP）：PostgREST 唯一选项
   - Phase 2（6 个月）：开发自建 ORM 作为可选项
   - Phase 3（12 个月）：用户可选择 PostgREST 或 ORM

**权衡接受**：
- ✅ 接受：MVP 阶段依赖 PostgREST 外部项目
- ✅ 接受：复杂业务逻辑需要通过函数服务或工作流实现
- ✅ 接受：未来可能需要开发自建 ORM（长期投资）
- ❌ 拒绝：MVP 阶段自建 ORM（时间成本过高，延误上市）

**技术实现**：

```yaml
# apprun.yml - MVP 配置
data:
  engine: postgrest  # MVP 唯一选项
  connection:
    host: postgres
    database: apprun
    
models:
  Server:
    fields:
      name: string
      ip: string
    # PostgREST 自动生成：
    # GET    /api/servers
    # POST   /api/servers
    # PATCH  /api/servers/:id
    # DELETE /api/servers/:id
```

**未来扩展路径**：

```yaml
# apprun.yml - Phase 2 配置
data:
  engine: orm  # 或 postgrest
  features:
    - hooks       # ORM 专属
    - validation  # ORM 专属
    - cache       # ORM 专属
```

**验证指标**：
- PostgREST 集成时间 < 1 周
- CRUD API 自动生成成功率 100%
- API 响应时间 P95 < 200ms
- 复杂查询支持度 > 90%（关联、过滤、分页）

**降级方案**：
- 如果 PostgREST 性能或功能不满足需求，立即启动 ORM 开发
- 目标：6 个月内完成 ORM 作为备选方案

---

### ADR 总结：决策原则与模式

通过以上 5 个关键架构决策记录，我们提炼出 apprun 的**架构决策原则**：

#### 核心决策原则

1. **轻量级优先原则**
   - 每个决策都要评估对"1GB 内存 + 20s 启动"目标的影响
   - 示例：选择 Go 单语言栈、NATS 而非 Kafka

2. **渐进式复杂度原则**
   - 简单场景零代码，复杂场景完全灵活
   - 示例：配置 DSL + 代码扩展、PostgREST + 未来 ORM

3. **用户价值驱动原则**
   - MVP 优先验证核心价值（95% 时间节省）
   - 示例：PostgREST 快速验证 vs 自建 ORM 长期投资

4. **风险对冲原则**
   - 关键决策保留降级路径和替代方案
   - 示例：双引擎可降级为单一 Temporal、PostgREST 可替换为 ORM

5. **务实平衡原则**
   - 拒绝极端方案，选择平衡的混合架构
   - 示例：单容器 vs 微服务 → 混合架构

#### 决策模式总结

| 决策领域 | 极端方案 A | 极端方案 B | **平衡方案（选择）** |
|---------|-----------|-----------|-------------------|
| **部署架构** | 完全单容器 | 完全微服务 | **混合架构**（核心合并+重服务独立） |
| **事件驱动** | 仅 NATS | 仅 Temporal | **双引擎协同**（NATS 指令+Temporal 执行） |
| **开发范式** | 纯代码 | 纯可视化 | **DSL + 代码扩展**（渐进式复杂度） |
| **语言栈** | 纯 Go | 多语言 | **核心 Go + 函数多语言**（边界清晰） |
| **数据层** | PostgREST | 自建 ORM | **MVP PostgREST + 保留 ORM 路径**（快速验证） |

#### 架构哲学

apprun 的架构决策体现了一种**务实创新主义**：

- ✅ **不盲目追求极简**：单一组件无法满足复杂需求
- ✅ **不盲目追求灵活**：完全微服务牺牲轻量级目标
- ✅ **不盲目追求自主**：成熟开源组件加速 MVP
- ✅ **追求平衡与克制**：每个决策都有明确的权衡和边界

这些架构决策记录不仅是技术文档，更是 apprun **设计哲学的具象化**，为后续架构演进提供了清晰的指导原则。
