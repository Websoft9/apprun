---
stepsCompleted: [1, 2, 3, 4, 6, 7, 8, 9, 10]
inputDocuments: 
  - "docs/analysis/product-brief-apprun-2025-12-12.md"
documentCounts:
  briefs: 1
  research: 0
  brainstorming: 0
  projectDocs: 0
workflowType: 'prd'
lastStep: 10
project_name: 'apprun'
user_name: 'Root'
date: '2025-12-18'
status: 'complete'
---

# Product Requirements Document - apprun

**Author:** Root
**Date:** 2025-12-18

## 执行摘要

### 产品愿景

**apprun** 是一个企业级的 Backend as a Service (BaaS) 平台，为企业产品开发提供统一的技术基础设施框架。通过集成认证、权限、数据模型、函数计算、工作流引擎（Temporal）、事件中心、国际化、存储、实时推送、API 网关和监控等核心模块，让开发团队专注于业务逻辑创新，而非重复实现基础设施。

**核心目标：** 减少 90% 的基础开发工作，将产品上市周期从 6 个月缩短到 2 个月。

### 核心问题

企业产品开发中，开发团队面临以下痛点：

- **重复劳动**：每个项目都要重新实现认证、权限、数据模型等通用模块
- **事件驱动复杂**：组件间事件传递、异步任务管理需要大量胶水代码
- **实时需求困难**：手写 WebSocket 逻辑，处理连接管理和状态同步
- **微服务集成繁琐**：服务间调用、路由转发缺乏统一管理
- **问题排查低效**：日志分散在各个服务，难以追踪和定位问题
- **质量不一致**：不同项目的基础实现存在差异，技术债务积累

### 解决方案

apprun 提供轻量级、模块化的 BaaS 平台，采用 **Go 语言构建**，包含以下核心模块：

#### 核心服务容器（合并部署）
这些服务在生产环境中作为单个容器运行，开发环境支持单镜像部署：

1. **🔐 认证与权限**
   - 统一的用户管理和访问控制（JWT + RBAC）
   - 企业级安全标准支持
   - 与 API 网关深度集成

2. **🚪 API 网关**
   - 统一微服务入口和路由转发
   - 集成认证授权
   - 基础路由和代理功能
   - *注：MVP 不包含限流、服务发现、熔断降级、灰度发布*

3. **📊 数据模型**
   - 可视化数据建模和自动 API 生成
   - 基于 PostgREST 或自建 ORM
   - 支持快速原型开发

4. **📡 实时数据推送**
   - WebSocket 服务端主动推送能力
   - 支持实时数据同步（数据变更 → 客户端更新）
   - 典型场景：持续部署状态推送、任务进度更新
   - *注：MVP 不包含房间/频道、消息持久化、送达确认*
   - *技术选型待架构阶段确定*

#### 独立服务容器

5. **🔄 工作流引擎（Temporal）**
   - **可靠的工作流编排**：处理复杂业务流程和长时间运行任务
   - 与事件中心集成：事件中心触发工作流，工作流发布事件
   - 支持事件驱动、定时触发、手工执行
   - **插件化节点架构**：SMTP、HTTP、数据库等节点可扩展
   - **用户自定义节点**：支持调用自己的微服务
   - 内置重试、补偿、状态管理机制
   - 基于 YAML/代码配置（不提供可视化设计器）
   - *注：工作流的业务编排能力不在 apprun 范围内，属于独立项目*

5b. **🔔 事件中心（Event Hub）**
   - 基于 NATS 的轻量级事件总线
   - **高性能事件流**：处理高并发、低延迟的事件传递
   - **发布-订阅模式**：模块间解耦通信
   - **与 Temporal 协同**：快速路由事件，触发工作流执行
   - 支持实时推送的事件源
   - 独立部署容器（与 Temporal 协同）
   - *注：作为 Temporal 的高性能补充，不替代工作流编排*

6. **⚡ 函数服务**
   - 无服务器函数执行环境
   - 基于 Docker/Containerd 或 WASM 运行时
   - 支持业务逻辑快速部署

7. **💾 存储服务**
   - 文件和对象存储解决方案
   - *注：MinIO 已停止开源，需选择轻量级替代方案或自研*

8. **🌍 国际化(i18n)**
   - 多语言内容管理和本地化
   - 支持全球化产品开发

9. **📊 日志与监控**
   - 集中式日志收集和查询
   - 性能指标监控
   - 分布式追踪
   - 告警规则配置

10. **🔔 事件中心（Event Hub）**
   - 轻量级高性能事件总线（基于 NATS）
   - 发布-订阅模式和点对点消息
   - 与 Temporal 协同工作
   - 支持模块间异步解耦通信
   - 为实时推送提供事件流基础
   - *注：作为 Temporal 的补充，处理高并发事件流*
   - *技术选型：NATS（Go 原生，轻量级）*

### 核心差异化

**轻量级部署优先**
- **开发环境**：单容器镜像，多服务进程，快速启动
- **生产环境**：核心服务合并容器（认证+权限+网关+数据+实时推送）+ 独立容器（工作流+函数+存储+i18n+监控）
- Go 语言单二进制编译，资源占用低
- 配置文件驱动的模块化启用
- 明确排除重量级方案（Supabase/Appwrite）

**事件驱动架构**
- **工作流引擎（Temporal）**：可靠的业务流程编排和长时间任务
- **事件中心（NATS）**：高性能事件路由和模块解耦通信
- 明确分工：Temporal 处理可靠性和状态管理，Event Hub 处理高吞吐事件流
- 插件化节点设计，用户可扩展自定义节点
- 支持事件驱动、定时任务、手工触发

**实时推送能力**
- 服务端主动推送（部署状态、任务进度）
- WebSocket 连接管理和状态同步
- 专注实时数据推送，不追求完整的即时通讯功能

**开发体验优先**
- 一行配置启用核心功能
- 自动 API 生成减少 CRUD 开发
- 统一认证授权，无需重复实现

**可观测性内置**
- 集中式日志查询，问题定位从小时级到分钟级
- 实时性能监控和告警
- 分布式追踪支持

### 目标用户

**主要用户：开发者**（如李明）
- 减少 90% 基础设施开发时间
- 专注业务逻辑创新
- 快速原型验证

**次要用户：架构师**（如王晓）
- 标准化架构，技术一致性
- 事件驱动架构统一管理
- 实时监控系统健康状况

**次要用户：产品经理**（如张丽）
- 产品上市周期从 6 个月缩短到 2 个月
- 迭代频率提升 3 倍
- 快速响应市场需求

### 成功指标

**3 个月目标：**
- 至少 3 个团队采用，开发效率提升 50%+
- 用户满意度评分 4.0/5

**12 个月目标：**
- 覆盖企业 80% 的产品项目
- 累计节省开发时间 1000+ 人天
- ROI 达到 300%

## 项目分类

**技术类型：** API Backend + Developer Platform
- BaaS 后端平台
- 开发者基础设施工具

**技术栈：** Go 语言 + Temporal 工作流引擎

**领域：** Developer Tools / Enterprise Infrastructure

**复杂度：** Medium-High
- 9 大核心模块集成
- 事件驱动架构
- 企业级安全和可扩展性
- 采用轻量级策略控制复杂度

**项目上下文：** Greenfield（绿地项目）

## 技术约束与决策

**已确定：**
- ✅ 编程语言：Go
- ✅ 工作流引擎：Temporal
- ✅ 部署模式：开发单镜像，生产核心合并+独立容器
- ✅ 工作流节点：插件化架构，支持用户扩展
- ❌ 不包含：工作流可视化设计器、业务编排能力

**待架构阶段明确：**
- ⏳ 平台事件总线与 Temporal 的集成模式
- ⏳ 实时推送技术选型（自建 vs 集成第三方）
- ⏳ 数据模型方案（PostgREST vs 自建）
- ⏳ 存储服务方案（MinIO 替代方案）
- ⏳ 函数运行时选择（Docker/Containerd vs WASM）

**明确不实现（MVP）：**
- ❌ 实时推送的房间/频道、消息持久化、送达确认
- ❌ API 网关的限流、服务发现、熔断降级、灰度发布
- ❌ 工作流的可视化设计器和业务编排能力

## 事件驱动架构设计原则

### 核心架构：Temporal + Event Hub 双引擎

apprun 采用 **Temporal 工作流引擎** 和 **Event Hub 事件中心** 双引擎协同的事件驱动架构，明确分工、各司其职。

#### **Temporal 工作流引擎**

**适用场景：**
- ✅ **可靠的业务流程编排**：多步骤、有状态的复杂工作流
- ✅ **长时间运行任务**：天/周/月级别的持久化任务
- ✅ **需要可靠性保证**：自动重试、补偿、状态恢复
- ✅ **事务性操作**：需要完整的执行历史和审计追踪

**不适用场景：**
- ❌ 高吞吐事件流处理（设计目标不是消息队列）
- ❌ 多对多事件广播（需要手动实现扇出）
- ❌ 毫秒级实时事件传递（相对延迟较高）
- ❌ 动态订阅关系（工作流启动时订阅已确定）

**Temporal 存储机制：**
- ✅ 存储工作流事件历史（WorkflowStarted, ActivityCompleted 等）
- ✅ 支持故障恢复和事件重放
- ✅ 支持 Signal 机制（类似点对点消息）
- ❌ 不支持传统的发布-订阅广播模式

#### **Event Hub 事件中心**

**适用场景：**
- ✅ **高性能事件流**：处理高并发、低延迟的事件传递
- ✅ **发布-订阅模式**：多对多事件广播和解耦通信
- ✅ **实时事件路由**：模块间异步通信的"高速公路"
- ✅ **动态订阅**：运行时添加/删除订阅者

**不适用场景：**
- ❌ 需要同步返回结果的场景（使用直接 RPC 调用）
- ❌ 事务性操作需要立即确认的场景
- ❌ 复杂的多步骤业务流程编排（使用 Temporal）

**设计模式：Fire-and-Forget（发布即忘）**

事件中心采用标准的发布-订阅模式，发布者发布事件后立即返回，不等待订阅者处理结果。

### 发布者职责

**应该做的：**
- ✅ 发布事件到事件中心
- ✅ 处理发布失败（网络错误、队列满等）
- ✅ 携带必要的事件元数据（event_id, timestamp, correlation_id）

**不应该做的：**
- ❌ 等待订阅者处理结果
- ❌ 关心有多少订阅者
- ❌ 假设订阅者一定会处理成功

**示例代码：**
```go
// 发布事件并立即返回
err := eventHub.Publish("user.registered", UserEvent{
    EventID:       uuid.New(),
    UserID:        user.ID,
    Email:         user.Email,
    Timestamp:     time.Now(),
    CorrelationID: ctx.RequestID(),
})
if err != nil {
    // 只处理发布失败（网络错误、队列满等）
    log.Error("Failed to publish event", err)
    return err
}
// 事件已接收，发布者继续执行
log.Info("Event published successfully")
```

### 订阅者职责

**应该做的：**
- ✅ 异步处理接收到的事件
- ✅ 自行处理失败重试和错误记录
- ✅ 实现幂等性（同一事件可能收到多次）
- ✅ 可以发布新事件通知处理结果（可选）

**不应该做的：**
- ❌ 依赖同步响应给发布者
- ❌ 假设事件处理一定成功
- ❌ 阻塞事件处理流程

**示例代码：**
```go
// 订阅者：异步处理事件
eventHub.Subscribe("user.registered", func(event UserEvent) {
    err := sendWelcomeEmail(event.Email)
    if err != nil {
        // 订阅者自己处理失败（重试、记录日志、告警）
        log.Error("Failed to send welcome email", err)
        
        // 可选：发布失败事件到死信队列
        eventHub.Publish("user.email.failed", FailedEvent{
            OriginalEvent:  event,
            ErrorMessage:   err.Error(),
            RetryCount:     3,
            CorrelationID:  event.CorrelationID,
        })
    } else {
        // 可选：发布成功事件
        eventHub.Publish("user.email.sent", EmailSentEvent{
            UserID:        event.UserID,
            Email:         event.Email,
            CorrelationID: event.CorrelationID,
        })
    }
})
```

### 结果反馈机制（可选）

如果发布者需要知道处理结果，可采用 **"回调事件模式"**：

**双向事件流：**
1. 发布者发布事件（带 `correlation_id`）
2. 订阅者处理并发布结果事件（成功/失败）
3. 发布者订阅结果事件，通过 `correlation_id` 匹配

**优势：**
- ✅ 保持异步解耦
- ✅ 发布者可以选择是否关心结果
- ✅ 不阻塞发布者继续执行

**示例场景：**
```
1. 认证模块 → Event Hub 发布 "user.registered" (correlation_id: abc-123)

2. 邮件服务 → Event Hub 发布 "user.email.sent" (correlation_id: abc-123)
   或
   邮件服务 → Event Hub 发布 "user.email.failed" (correlation_id: abc-123)

3. 认证模块订阅 "user.email.sent" 和 "user.email.failed"
   根据 correlation_id 匹配原始请求
```

### 何时不使用事件中心

以下场景不应该使用事件中心，应该使用直接调用：

- ❌ **需要同步返回结果**：API 网关调用验证服务
- ❌ **事务性操作需要立即确认**：支付处理
- ❌ **请求-响应模式的 API 调用**：数据查询

**反模式示例：**
```go
// ❌ 错误：将事件中心当作 RPC 使用
result := eventHub.PublishAndWait("validate.request", request) // 不要这样做

// ✅ 正确：直接调用
result := validationService.Validate(request)
```

### Temporal 与 Event Hub 协同

**典型集成模式：**

**模式 1：Event Hub 触发 Temporal 工作流**
```
业务模块 → Event Hub 发布 "order.created"
           ↓
        Temporal 订阅 → 启动订单处理工作流
           ↓
        工作流编排：库存扣减 → 支付 → 物流 → 通知
```

**模式 2：Temporal 发布事件到 Event Hub**
```
Temporal 工作流执行中
  ↓
发布中间状态事件 → Event Hub
  ↓
多个订阅者接收：
  - 实时推送模块 → WebSocket 推送到前端
  - 统计服务 → 更新指标
  - 审计服务 → 记录日志
```

**模式 3：混合流程**
```
用户注册 → Event Hub 发布 "user.registered"
  ↓
订阅者们并行处理：
  - Temporal 工作流（发送欢迎邮件 + 创建用户资料）
  - 统计服务（更新注册指标）
  - 积分服务（后续动态添加）
```

### 性能特性与保证

**Event Hub 性能指标：**
- ✅ **事件发布延迟**：< 5ms（P95）
- ✅ **端到端延迟**：< 50ms（P95，发布到订阅者接收）
- ✅ **吞吐量**：≥ 10000 消息/秒
- ✅ **可靠性**：至少一次交付（at-least-once delivery）

**Temporal 性能指标：**
- ✅ **工作流启动延迟**：< 1 秒
- ✅ **事件持久化**：100%（所有工作流事件历史）
- ✅ **故障恢复**：自动从历史重放
- ✅ **可靠性**：至少一次执行（at-least-once execution）

### 最佳实践

**事件命名规范：**
```
<资源>.<动作>.<状态>

示例：
- user.registered          （用户注册完成）
- user.email.sent          （邮件发送成功）
- user.email.failed        （邮件发送失败）
- deployment.status.update （部署状态更新）
- order.created            （订单创建）
- order.payment.completed  （订单支付完成）
```

**事件数据结构：**
```go
type Event struct {
    EventID       string    `json:"event_id"`       // 唯一事件 ID
    EventType     string    `json:"event_type"`     // 事件类型
    Timestamp     time.Time `json:"timestamp"`      // 时间戳
    CorrelationID string    `json:"correlation_id"` // 关联 ID（可选）
    Source        string    `json:"source"`         // 事件源
    Data          any       `json:"data"`           // 事件数据
}
```

**幂等性设计：**
```go
// 订阅者应该实现幂等性
func handleUserRegistered(event UserEvent) {
    // 检查是否已处理过此事件
    if alreadyProcessed(event.EventID) {
        log.Info("Event already processed, skipping")
        return
    }
    
    // 处理事件
    processEvent(event)
    
    // 标记为已处理
    markAsProcessed(event.EventID)
}
```

**错误处理策略：**
```go
// 重试策略
type RetryPolicy struct {
    MaxRetries    int           // 最大重试次数
    InitialDelay  time.Duration // 初始延迟
    MaxDelay      time.Duration // 最大延迟
    BackoffFactor float64       // 退避因子
}

// 死信队列
if retryCount > maxRetries {
    eventHub.Publish("dlq.failed_events", FailedEvent{
        OriginalEvent: event,
        Error:         err.Error(),
        RetryCount:    retryCount,
    })
}
```

### 技术选型说明

**Event Hub 技术选型：NATS**

选择理由：
- ✅ Go 原生实现，与 apprun 技术栈一致
- ✅ 轻量级部署，资源占用低
- ✅ 高性能（支持百万级消息/秒）
- ✅ 内置发布-订阅、点对点、请求-响应模式
- ✅ 简单易用，学习曲线低

替代方案对比：
- **Kafka**：过于重量级，不符合 apprun 轻量化原则
- **RabbitMQ**：部署复杂，资源占用较高
- **Redis Streams**：功能有限，可靠性保证较弱

## 成功标准

### 用户成功

#### 魔力时刻（Aha Moments）

**开发者的顿悟时刻：**

1. **部署即可用** - 启动 apprun 后立即访问自动生成的 API
   - 无需编写任何 CRUD 代码
   - 数据模型配置即生成完整的 RESTful API
   - 从安装到第一个 API 调用成功 < 5 分钟

2. **配置驱动开发** - 通过配置而非编码实现功能
   - 定义数据模型 → 自动生成 CRUD API
   - 配置认证方式 → 多种认证策略开箱即用
   - 指定 API 路径 → WebSocket 实时推送自动启用

3. **实时状态可见** - 第一次看到实时推送的部署状态
   - 持续部署进度实时更新到前端
   - 无需手写 WebSocket 逻辑
   - 连接管理和状态同步自动处理

#### 典型成功场景

**场景 1：服务器管理功能开发**

传统方式需要：
- 编写服务器数据模型（Entity/DTO）
- 实现 CRUD 接口（Create/Read/Update/Delete）
- 编写路由和控制器
- 实现认证和权限检查
- 测试所有 API 端点
- **预计时间：2-3 天**

使用 apprun：
- 配置服务器数据模型（YAML/可视化）
- API 自动生成并可访问
- 认证和权限自动集成
- （可选）指定 API 路径启用 WebSocket 实时推送
- **实际时间：1-2 小时**
- **时间节省：95%+**

**场景 2：实时数据推送**

传统方式需要：
- 实现 WebSocket 服务端逻辑
- 处理客户端连接管理
- 实现断线重连机制
- 设计消息推送协议
- **预计时间：1-2 周**

使用 apprun：
- 指定 API 路径启用 WebSocket
- 配置推送事件源
- 客户端自动接收实时更新
- **实际时间：< 1 天**
- **时间节省：90%+**

#### 可衡量的用户成功指标

**开发者李明视角：**
- ✅ **项目启动时间**：从需求到第一个可用原型 < 1 天（传统 1 周）
- ✅ **编码时间减少**：CRUD 功能从 2-3 天缩短到 1-2 小时（95% 时间节省）
- ✅ **代码质量提升**：基础设施相关 bug 减少 90%
- ✅ **专注业务逻辑**：每周节省 3-5 天基础设施开发时间
- ✅ **实时功能交付**：从 2 周缩短到 1 天（90% 时间节省）
- ✅ **问题排查效率**：集中式日志，从小时级缩短到分钟级
- ✅ **创新能力提升**：每月尝试的新业务功能数量增加 2 倍

**架构师王晓视角：**
- ✅ **架构一致性**：跨项目组件接口一致性 95%
- ✅ **扩展性**：新微服务集成从 2 周缩短到 2 天
- ✅ **技术债务**：基础设施重构需求减少 80%
- ✅ **系统稳定性**：生产环境故障率降低 50%
- ✅ **可观测性**：MTTR（平均恢复时间）降低 70%
- ✅ **事件驱动统一**：基于 Temporal 的统一事件总线

**产品经理张丽视角：**
- ✅ **上市时间**：产品发布周期从 6 个月缩短到 2 个月（67% 时间节省）
- ✅ **迭代频率**：每月发布新版本的能力提升 3 倍
- ✅ **用户满意度**：产品发布后用户满意度评分 4.5/5
- ✅ **市场响应**：新功能上线后 1 个月内用户采用率 70%

### 业务成功

#### 短期目标（3 个月）

**采用率指标：**
- ✅ 至少 3 个内部团队采用 apprun 作为开发平台
- ✅ 每个团队报告开发效率提升 50% 以上
- ✅ 至少 1 个完整的业务流程投入生产（涉及所有 10 大核心模块）

**满意度指标：**
- ✅ 用户满意度调查平均评分 4.0/5
- ✅ 至少 80% 的开发者表示愿意推荐给其他团队
- ✅ 收集到 50+ 有效的功能需求反馈

**技术验证：**
- ✅ MVP 所有核心模块验证可用
- ✅ 完成至少 2 个典型业务场景的端到端测试
- ✅ 轻量级部署目标达成（见技术成功标准）

#### 中期目标（12 个月）

**规模化采用：**
- ✅ 覆盖企业 80% 的产品项目（基于 apprun 开发）
- ✅ 累计节省开发时间 1000+ 人天
- ✅ 支持 10+ 个生产环境业务系统

**投资回报：**
- ✅ ROI（投资回报率）达到 300%
- ✅ 平台开发和维护成本 < 节省的人力成本的 30%
- ✅ 减少外部 SaaS 服务依赖，降低运营成本

**技术成熟度：**
- ✅ 生产环境稳定运行 6+ 个月
- ✅ 建立完整的文档和最佳实践库
- ✅ 形成内部社区和技术支持体系

#### 长期愿景（1-2 年）

**平台生态：**
- 成为企业数字化转型的核心平台
- 培养创新文化，员工专注于高价值工作
- 建立插件市场和开发者生态

### 技术成功

#### MVP 阶段技术验证目标

**功能完整性：**
- ✅ 完成一个端到端的业务流程，涉及所有 10 大核心模块：
  1. 认证与权限 - 用户登录和访问控制
  2. API 网关 - 统一入口和路由
  3. 数据模型 - 自动 CRUD API 生成
  4. 实时推送 - WebSocket 状态更新
  5. 工作流引擎 - 事件驱动任务编排
  6. 函数服务 - 自定义业务逻辑
  7. 存储服务 - 文件上传和访问
  8. 国际化 - 多语言支持
  9. 日志与监控 - 集中式可观测性
  10. 事件中心 - 高性能事件路由和解耦通信

**轻量级部署目标：**
- ✅ **内存占用** ≤ 1GB（核心服务容器 + 必要依赖）
- ✅ **启动时间** ≤ 20 秒（从容器启动到服务可用）
- ✅ **镜像大小** ≤ 500MB（开发环境单镜像）
- ✅ **最小依赖**：PostgreSQL + 可选存储组件

**性能基准（正常标准）：**
- ✅ **API 响应时间**：P95 < 200ms（简单查询）
- ✅ **并发处理**：单实例支持 1000+ 并发请求
- ✅ **WebSocket 连接**：单实例支持 5000+ 并发连接
- ✅ **工作流执行**：事件触发到执行延迟 < 1 秒
- ✅ **事件吞吐量**：≥ 10000 消息/秒（Event Hub）
- ✅ **事件延迟**：P95 < 50ms（发布到订阅接收）

**稳定性基准（正常标准）：**
- ✅ **可用性**：开发环境 95%+，生产环境 99%+
- ✅ **错误率**：< 0.1%（系统错误，非业务逻辑错误）
- ✅ **数据一致性**：事务完整性保证，无数据丢失
- ✅ **自动恢复**：服务崩溃后自动重启和恢复

**可扩展性验证：**
- ✅ 支持水平扩展（多实例部署）
- ✅ 支持模块化启用/禁用（按需加载）
- ✅ 支持插件化节点扩展（工作流自定义节点）
- ✅ 支持多租户隔离（数据和权限）

**开发体验验证：**
- ✅ 配置驱动：数据模型配置即生成 API（零代码）
- ✅ 快速启动：从安装到第一个 API 调用 < 5 分钟
- ✅ 简化配置：核心功能通过配置文件启用
- ✅ 完整文档：覆盖所有核心模块的使用指南

### 可衡量的里程碑

#### Phase 1: MVP 交付（前 3 个月）

**Month 1：核心模块验证**
- Week 1-2：认证、权限、API 网关基础功能
- Week 3-4：数据模型和自动 API 生成

**Month 2：集成与扩展**
- Week 5-6：工作流引擎（Temporal）集成和事件驱动
- Week 7-8：实时推送、函数服务、存储服务

**Month 3：完善与上线**
- Week 9-10：国际化、日志监控完善
- Week 11：端到端业务流程验证
- Week 12：第一个内部团队试用和反馈

**关键里程碑检查点：**
- ✅ 技术可行性验证（所有模块可用）
- ✅ 轻量级目标达成（内存 ≤ 1GB，启动 ≤ 20s）
- ✅ 典型场景验证（服务器管理 + 实时推送）
- ✅ 至少 1 个团队采用并给出正面反馈

#### Phase 2: 生产就绪（3-6 个月）

- 性能优化和压力测试
- 生产环境部署和监控
- 完整的文档和培训材料
- 3 个团队正式采用

#### Phase 3: 规模化推广（6-12 个月）

- 高级功能迭代（基于用户反馈）
- 插件市场和生态建设
- 覆盖 80% 企业项目
- ROI 300% 达成

## 产品范围

### MVP - 最小可行产品

**必须包含（所有 10 大核心模块）：**

1. **认证与权限**
   - JWT + RBAC 基础实现
   - 与 API 网关集成
   - 支持基础用户管理

2. **API 网关**
   - 统一入口和路由转发
   - 认证集成
   - 基础代理功能

3. **数据模型**
   - 配置化数据模型定义
   - 自动 CRUD API 生成
   - PostgreSQL 集成

4. **实时推送**
   - WebSocket 服务端推送
   - 基础连接管理
   - 指定路径启用推送
   - 与事件中心集成（接收事件源）

5. **工作流引擎（Temporal）**
   - 事件驱动、定时触发、手工执行
   - 基础节点（HTTP、SMTP、数据库）
   - 插件化架构支持用户自定义节点
   - 与事件中心集成（监听事件、发布事件）

6. **函数服务**
   - 基础函数运行时
   - 支持 Go 函数部署
   - 与工作流集成

7. **存储服务**
   - 基础文件上传和访问
   - 轻量级存储方案（MinIO 替代品或自研）

8. **国际化(i18n)**
   - 基础多语言配置
   - 内容管理和切换

9. **日志与监控**
   - 集中式日志收集
   - 基础性能指标监控
   - 简单告警配置

10. **事件中心（Event Hub）**
    - 基于 NATS 的轻量级事件总线
    - 发布-订阅基础实现
    - 与 Temporal 和实时推送的集成点
    - 模块间解耦通信

**MVP 成功标准：**
- ✅ 完整端到端业务流程验证
- ✅ 轻量级部署目标达成
- ✅ 典型场景时间节省 90%+
- ✅ 至少 1 个团队生产使用

### 增长功能（MVP 后 3-6 个月）

**性能与规模化：**
- 高级性能优化和缓存策略
- 水平扩展和负载均衡
- 高可用和灾备机制

**开发体验增强：**
- CLI 工具和脚手架
- 可视化数据模型设计器
- 更丰富的工作流节点库

**企业级功能：**
- 多租户管理和隔离
- 高级 RBAC 和细粒度权限
- 审计日志和合规支持

### 未来愿景（6-12 个月）

**高级功能：**
- API 网关的限流、熔断、灰度发布
- 实时推送的房间/频道、消息持久化
- 工作流可视化监控和调试
- AI 驱动的日志异常检测

**生态建设：**
- 插件市场和社区
- SDK 和集成库
- 第三方服务集成

**平台化：**
- 低代码开发能力
- 服务网格集成
- 智能化运维（AIOps）

## 用户旅程

### 旅程 1：李明 - 从基础设施苦力到业务创新者

李明是一位经验丰富的后端开发者，已经在企业工作了 5 年。每次接到新项目，他都要花费大量时间重复实现相同的功能：用户认证、权限管理、数据库 CRUD、文件上传等。最让他沮丧的是，每周都有 3-5 天时间被这些"重复劳动"占据，真正用于创新业务逻辑的时间少之又少。

**转折点来了。** 某个周一早晨，技术总监在团队会议上宣布引入 apprun 作为新的开发平台。李明心想："又是一个新工具，又要学习新的东西。"但他还是决定试一试。

**第一次接触 apprun：** 李明接到一个任务——为公司的运维系统增加服务器管理功能。传统方式下，他需要：
1. 设计服务器数据模型（字段、关系、验证规则）
2. 编写 Entity 类和 DTO 对象
3. 实现 CRUD 接口（Create/Read/Update/Delete）
4. 编写路由和控制器
5. 实现认证和权限检查
6. 编写单元测试
7. 调试和优化

**预计时间：2-3 天。**

但使用 apprun 后，李明打开配置文件，用 YAML 格式定义了服务器数据模型：

```yaml
models:
  Server:
    fields:
      name: string
      ip_address: string
      status: enum[active, inactive, maintenance]
      created_at: timestamp
    auth: jwt
    permissions: rbac
```

**保存配置，重启 apprun。5 分钟后，API 就自动生成了！**

李明难以置信地测试了一下：
- `GET /api/servers` - 查询所有服务器
- `POST /api/servers` - 创建新服务器
- `PUT /api/servers/:id` - 更新服务器
- `DELETE /api/servers/:id` - 删除服务器

**认证和权限自动集成，数据验证自动处理。** 李明的第一反应是："这不可能这么简单吧？"

**魔力时刻：** 当他第一次成功调用自动生成的 API 时，李明意识到："原来开发可以这么快！"这 2-3 天的工作量，在 apprun 中只需要 1-2 小时的配置时间。**时间节省 95%！**

**更大的突破：** 李明后来需要实现实时部署状态推送功能。传统方式下，他需要手写 WebSocket 服务端逻辑、处理连接管理、实现断线重连机制——预计需要 1-2 周。但在 apprun 中，他只需要在配置文件中指定一个 API 路径启用 WebSocket：

```yaml
realtime:
  paths:
    - /api/deployments/status
```

**< 1 天完成！** 客户端自动接收实时更新，连接管理和状态同步完全自动化。

**六个月后：** 李明已经交付了 8 个新功能模块，是以前的 3 倍速度。他每周节省的 3-5 天时间，全部用于探索新技术和优化业务逻辑。团队评审会上，他提出的创新方案数量是以前的 2 倍。李明不再是"基础设施苦力"，而是真正的"业务创新者"。

---

### 旅程 2：王晓 - 从技术债务危机到架构掌控者

王晓是公司的企业架构师，负责确保所有项目的技术标准和架构一致性。但过去两年，他陷入了一个噩梦：公司快速扩张，10 个产品项目各自为政，每个团队都用不同的方式实现认证、数据访问、微服务通信。技术债务像滚雪球一样累积，系统整体健康状况难以评估。

**危机爆发：** 一次生产环境故障，因为日志分散在各个服务，王晓花了整整 4 小时才定位到问题根源。更糟糕的是，当他想统一微服务架构时，发现每个项目的 API 网关、认证方式、监控方案都不一样，迁移成本巨大。

**apprun 带来的转机：** 技术总监决定引入 apprun 作为统一开发平台。王晓一开始持怀疑态度："又一个'银弹'方案吗？"但当他深入研究 apprun 的架构设计后，眼前一亮：

1. **统一的 API 网关** - 所有微服务的入口和路由标准化
2. **基于 Temporal 的事件总线** - 统一的事件驱动架构
3. **集中式日志与监控** - 所有服务的可观测性统一管理
4. **标准化认证授权** - JWT + RBAC 跨项目一致

**第一个试点项目：** 王晓选择了一个中型项目作为 apprun 试点。他最担心的问题是："现有微服务如何迁移？"但 apprun 的设计让他惊喜：

- 旧服务可以通过 API 网关逐步接入，无需一次性重写
- 工作流引擎的插件化节点支持调用现有微服务
- 渐进式迁移，风险可控

**魔力时刻：** 两周后，试点项目成功部署。王晓打开 apprun 的监控 dashboard，实时看到：
- 所有微服务的健康状况
- API 响应时间、错误率、吞吐量
- 集中式日志查询，支持分布式追踪

**问题排查从小时级缩短到分钟级。** 当再次发生生产故障时，王晓通过集中式日志，5 分钟就定位到问题并解决。MTTR（平均恢复时间）降低了 70%！

**一年后：** 公司 80% 的项目已经基于 apprun 开发，技术架构高度一致。新微服务集成从 2 周缩短到 2 天，架构一致性达到 95%。王晓不再疲于救火，而是专注于战略设计和技术创新。

---

### 旅程 3：张丽 - 从项目延误到快速迭代女王

张丽是一位敏捷产品经理，管理着 3 个并行产品线。她最大的痛苦是产品上市周期长达 6 个月，等功能开发完成时，市场需求已经变化。竞争对手总能更快推出新功能，让她感到无力。

**最糟糕的一次：** 一个重要的客户功能需求，张丽的团队花了 4 个月开发，最终上线时客户说："我们已经用竞争对手的产品了，这个功能对我们已经不重要了。"张丽沮丧极了。

**apprun 改变游戏规则：** 当技术团队开始使用 apprun 后，张丽注意到开发速度明显提升。李明告诉她："张经理，我现在每周能完成的功能是以前的 3 倍。"

**第一次快速迭代体验：** 张丽接到一个紧急需求——为企业客户增加多租户管理功能。传统方式下，这需要：
- 2 周需求分析
- 4 周开发（认证、权限、数据隔离）
- 2 周测试
- **总计 8 周（2 个月）**

但基于 apprun：
- 1 周需求分析（不变）
- **1 周开发**（数据模型配置 + apprun 自动多租户隔离）
- 1 周测试
- **总计 3 周！**

**魔力时刻：** 当张丽在第 3 周的演示会上向客户展示新功能时，客户惊讶地说："你们这么快就做出来了？我以为至少需要 2 个月！"张丽第一次感受到"快速响应市场"的快感。

**六个月后：** 张丽的产品迭代频率从每季度 1 次提升到每月 2-3 次。用户满意度从 3.2/5 提升到 4.5/5。更重要的是，张丽的产品线在市场竞争中开始占据主动，而不是被动追赶。产品上市周期从 6 个月缩短到 2 个月，ROI 达到 300%。

---

### 旅程 4：陈强（平台管理员）- 掌控 apprun 平台的守护者

陈强是公司新招的平台管理员，负责管理 apprun 平台本身。他的主要职责包括：配置核心服务、监控系统健康、管理租户和权限、处理平台级故障。

**入职第一天：** 陈强有些紧张，毕竟 apprun 支撑着公司 80% 的产品开发。技术总监告诉他："apprun 设计很简洁，你很快就能上手。"

**第一个任务：为新项目创建租户**

传统方式下，陈强需要：
1. 手动创建数据库 schema
2. 配置独立的认证规则
3. 设置权限隔离
4. 配置监控和日志

但在 apprun 中，陈强打开管理控制台，点击"创建租户"：

```yaml
tenant:
  name: "新产品线"
  plan: pro
  resources:
    max_users: 100
    max_storage: 10GB
```

**5 分钟完成！** apprun 自动创建了独立的数据空间、配置了认证和权限隔离、启用了监控。

**魔力时刻：** 某天凌晨 3 点，apprun 的告警系统通知陈强："核心服务容器内存使用率 85%"。陈强打开监控 dashboard，立即看到：
- 实时内存占用趋势
- CPU 使用率历史曲线
- 慢查询日志

他快速定位到问题：某个租户的数据查询效率低下。陈强通过管理控制台临时限制了该租户的资源配额，然后联系开发团队优化查询。**整个过程 15 分钟，系统未发生故障。**

**三个月后：** 陈强管理着 15 个租户、100+ 开发者。apprun 的轻量级设计让他可以轻松扩展和维护。系统可用性保持在 99.5% 以上。

---

### 旅程 5：赵敏（运维工程师）- 从半夜救火到自动化守护

赵敏是公司的运维工程师，负责部署和维护所有生产环境服务。在使用 apprun 之前，她的生活充满了半夜被叫醒、紧急修复故障、手动部署更新的噩梦。

**最糟糕的一次：** 凌晨 2 点，生产环境崩溃。赵敏被电话叫醒，远程登录服务器，发现日志分散在 8 个不同的服务中。她花了整整 3 小时才定位到问题，然后手动重启服务。第二天上班时，赵敏已经 24 小时没合眼。

**apprun 的救赎：** 公司引入 apprun 后，赵敏的第一反应是："又要学习新的部署方式吗？"但当她看到 apprun 的部署文档时，眼前一亮：

**开发环境部署：**
```bash
docker run -d apprun/apprun:latest
```
**一个镜像，20 秒启动，内存占用 < 1GB。**

**生产环境部署：**
```yaml
# docker-compose.yml
services:
  apprun-core:
    image: apprun/core:latest
    environment:
      - MODULES=auth,gateway,data,realtime
  temporal:
    image: temporalio/temporal:latest
  postgres:
    image: postgres:14
```

**魔力时刻：** 第一次使用 apprun 部署新服务时，赵敏惊讶地发现：
- 启动时间 < 20 秒
- 内存占用 < 1GB
- 集中式日志自动收集
- 健康检查和自动重启内置

更重要的是，当某个服务崩溃时，apprun 会自动重启并恢复，无需赵敏半夜起床。

**六个月后：** 赵敏的半夜紧急电话从每月 5-6 次降低到每月 0-1 次。系统可用性从 95% 提升到 99%+。赵敏终于可以安心睡觉了。

---

### 旅程 6：刘洋（API 集成开发者）- 轻松集成的第三方开发者

刘洋是一家合作伙伴公司的开发者，需要将他们的 SaaS 产品与客户公司的 apprun 平台集成。他过去集成过很多企业系统，每次都是噩梦：文档不全、API 不一致、认证复杂。

**第一次接触 apprun API：** 刘洋打开 apprun 的 API 文档，惊喜地发现：
- 标准的 RESTful API 设计
- 完整的 OpenAPI 规范文档
- 清晰的认证说明（JWT）
- 丰富的代码示例

**第一个 API 调用：**
```bash
# 获取 JWT Token
curl -X POST https://api.example.com/auth/login \
  -d '{"email": "developer@partner.com", "password": "xxx"}'

# 调用数据 API
curl -X GET https://api.example.com/api/servers \
  -H "Authorization: Bearer <token>"
```

**成功！** 刘洋花了不到 1 小时就完成了第一个集成测试。

**更强大的功能：** 刘洋需要实时接收客户系统的部署状态更新。apprun 的实时推送 API 让这变得简单：

```javascript
const ws = new WebSocket('wss://api.example.com/api/deployments/status');
ws.onmessage = (event) => {
  const status = JSON.parse(event.data);
  console.log('部署状态:', status);
};
```

**连接管理和断线重连自动处理。** 刘洋不需要编写复杂的重连逻辑。

**两周后：** 刘洋完成了完整的集成，比预期提前了 1 周。客户对集成质量非常满意，续约了 3 年合作。

---

### 旅程 7：孙薇（技术支持工程师）- 快速排查问题的侦探

孙薇是技术支持团队的工程师，每天接到大量用户的问题报告。在使用 apprun 之前，她排查问题的流程是：

1. 收集用户描述
2. 联系开发团队获取日志访问权限
3. 在多个服务的日志中搜索相关信息
4. 拼凑完整的错误链路
5. 向开发团队反馈

**预计时间：2-4 小时，甚至更长。**

**某天，一个紧急问题：** 用户报告"服务器创建失败，但不知道原因"。以前，孙薇需要联系开发团队，等待他们查看日志。

但现在，孙薇打开 apprun 的支持控制台：

**集中式日志查询：**
```
搜索：user_id=12345 AND action=create_server AND timestamp>now-1h
```

**1 秒内找到相关日志：**
```
[ERROR] 2025-12-18 10:23:45 - Server creation failed
[CAUSE] Insufficient storage quota for tenant
[TRACE] Request ID: abc-123-xyz
```

**魔力时刻：** 孙薇立即看到了完整的错误链路，包括：
- 用户操作时间
- 失败原因（存储配额不足）
- 请求追踪 ID
- 相关的所有微服务调用记录

孙薇回复用户："您的账户存储配额已满，请升级套餐或清理旧文件。"

**问题排查从 2-4 小时缩短到 5 分钟！**

**三个月后：** 孙薇的平均问题解决时间从 3 小时降低到 30 分钟。用户满意度从 3.5/5 提升到 4.7/5。更重要的是，孙薇现在可以独立解决 80% 的问题，无需频繁打扰开发团队。

---

### 旅程需求总结

这些用户旅程揭示了 apprun 需要的核心能力：

#### 开发者旅程（李明）揭示需求：
- 配置驱动的数据模型定义
- 自动 CRUD API 生成
- 一键启用实时推送
- 认证和权限自动集成
- 零代码实现基础功能

#### 架构师旅程（王晓）揭示需求：
- 统一的 API 网关和路由管理
- 基于 Temporal 的事件驱动架构
- 集中式日志和分布式追踪
- 实时监控 dashboard
- 渐进式迁移支持

#### 产品经理旅程（张丽）揭示需求：
- 快速原型开发能力
- 多租户管理功能
- 配置化功能启用
- 版本迭代和发布管理

#### 平台管理员旅程（陈强）揭示需求：
- 租户管理控制台
- 资源配额和隔离
- 系统健康监控
- 告警和通知机制

#### 运维工程师旅程（赵敏）揭示需求：
- 轻量级部署（单镜像/Docker Compose）
- 快速启动（≤ 20 秒）
- 低资源占用（≤ 1GB）
- 自动健康检查和重启
- 集中式日志收集

#### API 集成开发者旅程（刘洋）揭示需求：
- 标准 REST API 设计
- 完整的 API 文档（OpenAPI）
- 简单的 JWT 认证
- WebSocket 实时推送 API
- 丰富的代码示例

#### 技术支持旅程（孙薇）揭示需求：
- 集中式日志查询界面
- 分布式追踪和请求 ID
- 支持人员访问控制
- 快速错误定位工具
- 用户操作审计日志

## 创新与新颖模式

### 核心创新理念

**apprun 的本质：配置即开发（Configuration as Development）**

apprun 不是传统的 BaaS 平台，而是一个**微服务组合的开发框架**，通过多种 DSL/YAML 驱动开发，将"写代码"转变为"写配置"。这个理念颠覆了传统的开发范式，让开发者专注于"描述需求"而非"实现细节"。

### 创新领域 1：轻量级架构突破

#### 技术挑战

如何在 1GB 内存和 20 秒启动时间内，集成 10 个核心模块？这是 BaaS 平台的技术天花板。

#### 创新解决方案

**1. 轻量级组件选型**
- **策略**：优先选择轻量级组件或包
- **案例**：
  - 事件中心选择 NATS（Go 原生）而非 Kafka（JVM 重量级）
  - 工作流引擎选择 Temporal（可嵌入）而非独立服务网格
  - 存储服务排除 MinIO（已闭源且重），寻找轻量级替代

**2. Go 单二进制 + 多进程复用**
- **策略**：单一容器内运行多进程，共享资源
- **技术手段**：
  - Go 编译为单二进制文件，无外部依赖
  - 核心服务（认证+网关+数据+实时推送）合并为单进程
  - 进程间通过本地 IPC 通信，减少网络开销
  - 多进程部署在单一容器内，共享内存和文件系统

**3. 模块按需加载**
- **策略**：配置文件驱动的模块化启用
- **实现**：
  ```yaml
  # apprun.yml
  modules:
    enabled:
      - auth        # 必须
      - gateway     # 必须
      - data        # 按需
      - realtime    # 按需
      - workflow    # 按需
  ```
- **效果**：只加载业务需要的模块，进一步降低资源占用

#### 市场对比

| 维度 | Supabase | Appwrite | apprun |
|------|----------|----------|--------|
| **内存占用** | 2-4GB | 1.5-3GB | ≤ 1GB |
| **启动时间** | 60-120s | 45-90s | ≤ 20s |
| **容器数量** | 8-12 个 | 6-10 个 | 1-3 个 |
| **语言栈** | JS/TS/Rust | PHP/Node | 纯 Go |
| **定位** | 重量级全栈 | 中量级全栈 | 轻量级框架 |

**创新价值**：apprun 突破了"功能完整性"与"资源占用"的矛盾，证明企业级 BaaS 可以做到极致轻量。

---

### 创新领域 2：执行与指令解耦架构

#### 洞察来源

**发现**：单一事件总线（Kafka/RabbitMQ）只能发布事件，没有能力处理长时间运行的任务。

**问题场景**：
- 用户注册后需要发送欢迎邮件（可能重试多次）
- 订单创建后需要执行：库存扣减 → 支付 → 物流 → 通知（多步骤、有状态）
- 部署任务启动后需要持续推送状态更新（长时间运行）

**传统方案的不足**：
- **仅用事件总线**：无法保证执行可靠性，状态管理困难
- **仅用工作流引擎**：高并发事件处理性能瓶颈，无法实时广播

#### 创新解决方案：双引擎协同架构

**核心洞察：将执行与指令解耦**

```
指令层（Event Hub - NATS）
  ↓ 快速路由、广播、解耦
  ↓
执行层（Temporal）
  ↓ 可靠编排、状态管理、长时间运行
  ↓
结果反馈（Event Hub）
```

**分工明确**：
- **Event Hub（NATS）**：处理"指令传递"
  - 高性能（10K+ msg/s）
  - 低延迟（< 50ms P95）
  - 动态订阅
  - 发布-订阅广播

- **Temporal**：处理"可靠执行"
  - 长时间运行任务（天/周/月级别）
  - 自动重试和补偿
  - 状态持久化和恢复
  - 执行历史审计

**创新价值**：
- ✅ 解决了事件总线的执行可靠性问题
- ✅ 解决了工作流引擎的高并发性能问题
- ✅ 两者协同，各司其职，优势互补

**业界对比**：
- **AWS Step Functions + SNS/SQS**：类似思路但重量级，需多个独立服务
- **Azure Logic Apps + Event Grid**：云厂商方案，无法轻量化部署
- **apprun Temporal + NATS**：开源组合，单容器部署，轻量级

---

### 创新领域 3：配置即开发范式

#### 市场空白分析

**为什么企业不用现有方案？**

| 方案 | 问题 | apprun 优势 |
|------|------|------------|
| **Supabase/Appwrite** | 太重：多容器、高资源占用 | 单容器 1GB，20s 启动 |
| **自建脚手架** | 功能太少：缺乏集成和标准化 | 10 大模块集成，配置即开发 |
| **Spring Boot/Django** | 仍需写大量代码 | YAML 配置自动生成 API |
| **低代码平台** | 灵活性差，企业级功能不足 | 代码与配置混合，可扩展 |

#### apprun 的独特价值主张

**定位：配置驱动的微服务组合框架**

**核心能力**：
1. **多 DSL 驱动开发**
   ```yaml
   # 数据模型 DSL
   models:
     Server:
       fields: { name: string, ip: string }
       auth: jwt
   
   # 实时推送 DSL
   realtime:
     paths: [/api/servers]
   
   # 工作流 DSL
   workflows:
     - name: onboarding
       trigger: event.user.registered
       steps: [sendEmail, createProfile]
   ```

2. **配置 = 代码的等价性**
   - 传统开发：写 Entity → Controller → Service → Test（2-3 天）
   - apprun 开发：写 YAML 配置（1-2 小时）
   - 结果：完全等价的 API 功能

3. **渐进式复杂度**
   - **简单场景**：纯配置（CRUD、认证、推送）
   - **中等场景**：配置 + 工作流节点
   - **复杂场景**：配置 + 自定义函数 + 微服务集成

**创新价值**：
- ✅ 不是"低代码"（限制灵活性），而是"配置即代码"（保持灵活性）
- ✅ 不是"脚手架"（生成后分离），而是"运行时框架"（持续驱动）
- ✅ 不是"重量级平台"（独立部署），而是"嵌入式框架"（与业务共存）

---

### 创新领域 4：企业级轻量化平衡

#### 市场定位创新

**apprun 的"甜蜜点"**：

```
轻量级 ←------------------------→ 企业级
   
简单脚手架              apprun              Supabase
   ↓                      ↓                    ↓
功能少              10 大模块集成           功能全面
快速启动            1GB/20s 启动            资源密集
缺乏标准             标准化框架            标准化平台
无集成              完整集成                完整集成
```

**创新突破**：
- 传统认知：企业级 = 重量级 = 高资源占用
- apprun 证明：企业级功能可以通过轻量级架构实现

**技术手段**：
1. **Go 语言单栈**：无多语言运行时开销
2. **进程合并**：减少容器间通信
3. **按需加载**：不用的模块不加载
4. **轻量级组件**：NATS vs Kafka，PostgREST vs ORM
5. **配置驱动**：减少代码量和依赖

---

### 验证策略与风险缓解

#### MVP 验证计划（3 个月）

**注意**：创新假设的验证无法预知完整结果，但可以设计渐进式验证路径。

**Week 1-4：轻量级架构验证**
- ✅ 单容器集成 10 大模块
- ✅ 内存占用 ≤ 1GB 测试
- ✅ 启动时间 ≤ 20s 测试
- **风险**：资源占用超标 → 缓解：模块按需加载降级

**Week 5-8：双引擎协同验证**
- ✅ Temporal + NATS 集成测试
- ✅ 事件流性能测试（10K msg/s）
- ✅ 工作流可靠性测试（重试、补偿）
- **风险**：性能不达标 → 缓解：独立容器部署降级

**Week 9-12：配置即开发验证**
- ✅ 典型场景时间对比（CRUD 开发）
- ✅ 3 个试点团队反馈
- ✅ 开发效率提升量化（目标 50%+）
- **风险**：学习曲线过高 → 缓解：完善文档和示例

#### 创新风险与降级方案

**风险 1：轻量级目标无法达成**
- **降级方案**：拆分为多容器部署（类似 Supabase）
- **底线**：功能完整性优先于轻量化

**风险 2：双引擎复杂度过高**
- **降级方案**：简化为单一 Temporal，牺牲部分性能
- **底线**：工作流可靠性是核心价值

**风险 3：配置 DSL 表达能力不足**
- **降级方案**：支持自定义函数和微服务扩展
- **底线**：保持渐进式复杂度设计

---

### 市场竞争力分析

#### 差异化矩阵

| 维度 | Supabase | Appwrite | Spring Boot | apprun |
|------|----------|----------|-------------|--------|
| **部署复杂度** | 高（多容器） | 中（多容器） | 低（单 JAR） | **极低（单容器）** |
| **资源占用** | 重（2-4GB） | 中（1.5-3GB） | 中（512MB-1GB） | **轻（≤ 1GB）** |
| **功能完整性** | 全面 | 全面 | 需自建 | **全面且集成** |
| **开发范式** | SQL + JS | 控制台 + SDK | 代码 | **配置即开发** |
| **事件驱动** | 部分支持 | 基础支持 | 需自建 | **双引擎架构** |
| **企业级特性** | ✅ | ✅ | ✅ | ✅ |
| **学习曲线** | 中 | 低 | 高 | **中（配置为主）** |

**竞争优势**：
1. ✅ 唯一同时满足"轻量级"和"企业级"的 BaaS 框架
2. ✅ 唯一采用"配置即开发"范式的微服务框架
3. ✅ 唯一实现"双引擎协同"的事件驱动架构

#### 目标市场

**最适合 apprun 的场景**：
- 🎯 企业内部产品快速开发（80% 覆盖率目标）
- 🎯 中小型 SaaS 产品 MVP 验证
- 🎯 微服务架构标准化改造
- 🎯 现有系统的事件驱动升级

**不适合的场景**：
- ❌ 超大规模互联网应用（需专门优化）
- ❌ 极致性能要求场景（需裸金属优化）
- ❌ 完全低代码无代码需求（apprun 是框架不是平台）

---

### 创新总结

apprun 的创新不是单点突破，而是**系统性创新**：

1. **架构创新**：双引擎协同（执行与指令解耦）
2. **范式创新**：配置即开发（DSL 驱动）
3. **工程创新**：轻量级企业级（打破传统认知）
4. **定位创新**：微服务组合框架（填补市场空白）

这些创新共同构成了 apprun 的**不可替代性**，让它在 BaaS 市场中开辟了独特的赛道。

---

## 架构决策记录（Architecture Decision Records）

> **方法说明**：通过多位架构师的辩论和权衡分析，显性展示关键架构决策的深层逻辑。

### ADR-001：单容器 vs 微服务架构

#### 决策上下文

apprun 需要在开发环境提供极简部署体验，同时在生产环境支持水平扩展和高可用。

#### 参与架构师

**架构师 A（性能优化派）- 李云**
- **立场**：支持单容器部署
- **论据**：
  1. 进程间通信通过本地 IPC，零网络延迟
  2. 共享内存访问，减少数据序列化开销
  3. 简化部署配置，降低运维复杂度
  4. Go 单二进制编译，启动速度 < 20s
- **权衡认知**：牺牲了模块独立扩展能力

**架构师 B（云原生派）- 王浩**
- **立场**：主张完全微服务化
- **论据**：
  1. 每个模块独立扩展（如工作流引擎可独立扩容）
  2. 故障隔离更彻底（一个模块崩溃不影响其他）
  3. 技术栈更灵活（不同模块可用不同语言）
  4. 符合 Kubernetes 云原生最佳实践
- **权衡认知**：增加部署复杂度和资源占用

**架构师 C（务实平衡派）- 赵敏**
- **立场**：混合架构（核心合并 + 重服务独立）
- **论据**：
  1. 开发环境单容器，降低入门门槛
  2. 生产环境核心服务合并，重服务独立部署
  3. 核心服务（认证+网关+数据）耦合度高，合并收益大
  4. 重服务（Temporal+函数+存储）独立部署，灵活扩展
- **权衡认知**：增加部署配置复杂度，但最大化实用价值

#### 最终决策

**选择：混合架构（架构师 C 方案）**

**决策理由**：
1. **开发体验优先**：单容器部署让新用户 5 分钟上手
2. **生产灵活性**：核心合并容器 + 5 个独立容器的混合部署
3. **资源优化**：核心服务合并后内存占用 < 500MB
4. **扩展能力**：工作流引擎和函数服务可独立水平扩展

**权衡接受**：
- ✅ 接受：部署配置复杂度从"单一模式"增加到"两种模式"
- ✅ 接受：核心服务需要共同重启（但重启时间 < 20s）
- ❌ 拒绝：完全微服务化带来的 8-12 个容器管理成本

**验证指标**：
- 开发环境启动时间 ≤ 20s
- 核心合并容器内存 ≤ 500MB
- 生产环境总容器数 ≤ 6 个（1 核心 + 5 独立）

---

### ADR-002：Temporal + NATS 双引擎 vs 单一事件总线

#### 决策上下文

apprun 需要支持事件驱动架构，但面临性能与可靠性的双重挑战。

#### 参与架构师

**架构师 A（极简派）- 刘洋**
- **立场**：只用 NATS 事件总线
- **论据**：
  1. 架构极简，学习曲线低
  2. NATS 本身支持重试和持久化
  3. 减少一个核心依赖（Temporal）
  4. 部署和维护成本更低
- **权衡认知**：长时间运行任务和复杂工作流需要自行实现

**架构师 B（可靠性派）- 孙薇**
- **立场**：只用 Temporal 工作流引擎
- **论据**：
  1. Temporal 自带事件存储和状态管理
  2. 工作流可视化和调试能力强
  3. 内置重试、补偿、Saga 模式
  4. 企业级成熟度高（Uber/Netflix 验证）
- **权衡认知**：高并发事件广播性能瓶颈

**架构师 C（分层派）- 陈强**
- **立场**：双引擎协同（NATS 指令层 + Temporal 执行层）
- **论据**：
  1. **指令与执行分离**：NATS 处理高并发事件流，Temporal 处理可靠工作流
  2. **性能与可靠性兼得**：NATS 10K+ msg/s，Temporal 保证零丢失
  3. **灵活组合**：简单事件用 NATS，复杂流程用 Temporal
  4. **业界验证**：类似 AWS Step Functions + SNS/SQS 的思路
- **权衡认知**：架构复杂度增加，需要明确的使用场景指导

#### 最终决策

**选择：双引擎协同（架构师 C 方案）**

**决策理由**：
1. **核心洞察**："将执行与指令解耦" - 单一组件无法同时优化性能和可靠性
2. **性能验证**：NATS 事件延迟 < 50ms，Temporal 无法达到此性能
3. **可靠性验证**：Temporal 工作流零丢失，NATS 需要额外实现
4. **场景互补**：
   - 模块间通信（高频低重要性）→ NATS
   - 业务流程编排（低频高重要性）→ Temporal
   - 实时推送事件源 → NATS
   - 长时间运行任务 → Temporal

**权衡接受**：
- ✅ 接受：架构复杂度增加，需要设计原则文档（已完成）
- ✅ 接受：两个组件的学习成本
- ✅ 接受：集成和调试的额外工作
- ❌ 拒绝：性能瓶颈（单一 Temporal）或可靠性风险（单一 NATS）

**验证指标**：
- NATS 事件吞吐量 ≥ 10K msg/s
- NATS 事件延迟 P95 < 50ms
- Temporal 工作流执行成功率 > 99.9%
- 典型业务场景端到端延迟 < 100ms

**风险缓解**：
- **降级路径 1**：如果集成复杂度过高，简化为单一 Temporal（牺牲性能）
- **降级路径 2**：如果 NATS 可靠性不足，全部迁移到 Temporal（牺牲吞吐量）

---

### ADR-003：配置 DSL vs 低代码可视化

#### 决策上下文

apprun 的"配置即开发"理念需要选择开发者交互方式。

#### 参与架构师

**架构师 A（代码优先派）- 李明**
- **立场**：纯代码方式（类似 Spring Boot）
- **论据**：
  1. 开发者最熟悉，无学习成本
  2. IDE 支持好（智能提示、重构、调试）
  3. 版本控制和代码审查友好
  4. 灵活性最高，无表达能力限制
- **权衡认知**：开发效率提升有限，仍需写大量样板代码

**架构师 B（可视化派）- 张丽**
- **立场**：图形化低代码平台（类似 Appwrite）
- **论据**：
  1. 零代码体验，产品经理可直接配置
  2. 可视化工作流设计器，直观易懂
  3. 降低技术门槛，扩大用户群体
  4. 所见即所得，减少配置错误
- **权衡认知**：复杂场景表达能力不足，企业级功能受限

**架构师 C（DSL 平衡派）- 王晓**
- **立场**：YAML/DSL 配置 + 代码扩展
- **论据**：
  1. **YAML 配置**：简单场景（CRUD、认证）零代码
  2. **代码扩展**：复杂场景（自定义函数、微服务）完全灵活
  3. **渐进式复杂度**：从配置到代码的平滑过渡
  4. **版本控制友好**：纯文本配置文件，Git 管理
  5. **IDE 支持**：YAML Schema 提供智能提示
- **权衡认知**：需要学习 DSL 语法，但学习曲线可控

#### 最终决策

**选择：YAML DSL + 代码扩展（架构师 C 方案）**

**决策理由**：
1. **目标用户**：开发者（非业务人员），DSL 学习成本可接受
2. **核心价值**："配置即代码"而非"无代码" - 保持灵活性
3. **渐进式设计**：
   - **阶段 1**：纯 YAML 配置（90% 场景）
   - **阶段 2**：YAML + 工作流节点（95% 场景）
   - **阶段 3**：YAML + 自定义函数（99% 场景）
   - **阶段 4**：YAML + 微服务集成（100% 场景）
4. **版本控制**：纯文本配置文件，完美融入 Git 工作流

**权衡接受**：
- ✅ 接受：需要编写 YAML 配置文档和最佳实践
- ✅ 接受：DSL 语法的学习曲线（预计 1-2 小时上手）
- ✅ 接受：暂不提供可视化设计器（降低 MVP 复杂度）
- ❌ 拒绝：纯代码方式的低效率（无法达到 95% 时间节省目标）
- ❌ 拒绝：低代码平台的灵活性限制（企业级功能受限）

**配置示例**：

```yaml
# 简单场景：纯配置
models:
  Server:
    fields: { name: string, ip: string }
    auth: jwt

# 中等场景：配置 + 工作流
workflows:
  - name: onboarding
    trigger: event.user.registered
    steps:
      - sendEmail:
          template: welcome
      - createProfile:
          fields: [name, email]

# 复杂场景：配置 + 自定义函数
functions:
  - name: customValidation
    runtime: go
    source: ./functions/validation.go
    trigger:
      type: http
      path: /api/validate
```

**验证指标**：
- 典型 CRUD 场景配置时间 < 10 分钟
- 开发者学习 DSL 时间 < 2 小时
- 复杂场景代码扩展覆盖率 > 95%

---

### ADR-004：Go 单语言栈 vs 多语言微服务

#### 决策上下文

apprun 需要在语言灵活性和系统一致性之间权衡。

#### 参与架构师

**架构师 A（多语言派）- 刘洋**
- **立场**：支持多语言微服务（Go + Node + Python）
- **论据**：
  1. 不同模块选择最佳语言（如函数服务支持 Python）
  2. 吸引更多开发者（不限于 Go 开发者）
  3. 集成第三方服务更容易
  4. 灵活性最高
- **权衡认知**：运行时复杂度增加，资源占用翻倍

**架构师 B（单语言派）- 赵敏**
- **立场**：纯 Go 单语言栈
- **论据**：
  1. **轻量级目标**：单一运行时，无多语言开销
  2. **启动速度**：Go 二进制启动 < 1s，Node/Python 需 5-10s
  3. **内存占用**：Go 运行时 < 50MB，Node/Python > 100MB
  4. **维护成本**：单一工具链，依赖管理简单
  5. **性能一致性**：避免跨语言调用性能损耗
- **权衡认知**：函数服务灵活性受限（仅支持 Go）

**架构师 C（混合派）- 陈强**
- **立场**：核心 Go，函数服务支持多语言
- **论据**：
  1. apprun 核心用 Go 保证轻量级
  2. 函数服务通过容器隔离支持多语言
  3. 工作流节点可调用任意语言的微服务
  4. 平衡灵活性与性能
- **权衡认知**：函数服务需要额外的容器运行时

#### 最终决策

**选择：核心 Go + 函数服务多语言（架构师 C 方案）**

**决策理由**：
1. **轻量级优先**：apprun 核心用纯 Go 实现
   - 10 大核心模块全部 Go 开发
   - 单二进制编译，无外部运行时依赖
   - 启动时间 < 20s，内存占用 < 1GB
2. **灵活性扩展**：
   - 函数服务支持 Docker/Containerd 运行时（多语言）
   - 工作流节点可调用任意 HTTP 服务（语言无关）
   - 用户自定义节点可用任意语言开发
3. **边界清晰**：
   - apprun 平台 = 纯 Go
   - 用户业务逻辑 = 任意语言

**权衡接受**：
- ✅ 接受：apprun 核心模块仅限 Go 开发者贡献
- ✅ 接受：函数服务需要容器运行时（增加部署复杂度）
- ✅ 接受：多语言函数的启动延迟（冷启动）
- ❌ 拒绝：核心模块多语言（破坏轻量级目标）

**技术实现**：

```yaml
# apprun 核心：纯 Go
core:
  language: go
  modules: [auth, gateway, data, realtime, events, i18n, logs]

# 独立服务：可多语言但推荐 Go
services:
  temporal: go
  storage: go

# 函数服务：支持多语言
functions:
  runtimes:
    - go        # 原生支持，性能最优
    - python    # Docker 容器
    - nodejs    # Docker 容器
    - custom    # 自定义镜像
```

**验证指标**：
- apprun 核心启动时间 < 20s（纯 Go 目标）
- Go 函数冷启动 < 100ms
- Python/Node 函数冷启动 < 2s（容器启动）
- 核心模块内存占用 < 1GB（不含函数服务）

---

### ADR-005：PostgREST vs 自建 ORM

#### 决策上下文

apprun 的数据模型模块需要自动生成 CRUD API，面临技术选型决策。

#### 参与架构师

**架构师 A（PostgREST 派）- 李云**
- **立场**：集成 PostgREST 自动生成 API
- **论据**：
  1. **零代码**：数据库 schema 直接映射为 REST API
  2. **成熟稳定**：PostgREST 已被 Supabase 验证
  3. **性能优秀**：直接查询数据库，无 ORM 开销
  4. **功能丰富**：自动分页、排序、过滤、关联查询
  5. **开发速度**：无需编写 CRUD 代码
- **权衡认知**：业务逻辑扩展能力有限，依赖外部项目

**架构师 B（ORM 派）- 王浩**
- **立场**：自建 Go ORM（类似 GORM）
- **论据**：
  1. **完全控制**：自主开发，无外部依赖风险
  2. **灵活扩展**：业务逻辑、验证规则、钩子函数随意定制
  3. **性能优化**：针对 apprun 场景定制优化
  4. **版本稳定**：不受 PostgREST 版本变更影响
  5. **技术栈统一**：纯 Go 实现
- **权衡认知**：开发和维护成本高，功能成熟度需要时间

**架构师 C（混合派）- 孙薇**
- **立场**：MVP 用 PostgREST，后续可选 ORM
- **论据**：
  1. **MVP 快速验证**：PostgREST 开箱即用，加速上市
  2. **渐进式迁移**：API 层保持一致，底层实现可替换
  3. **用户选择**：配置文件指定 `dataEngine: postgrest | orm`
  4. **风险对冲**：PostgREST 失败可快速切换到 ORM
- **权衡认知**：维护两套实现增加长期成本

#### 最终决策

**选择：MVP 用 PostgREST，保留 ORM 扩展路径（架构师 C 方案）**

**决策理由**：
1. **MVP 优先**：3 个月时间紧张，PostgREST 加速开发
2. **功能验证**：PostgREST 完整功能可验证"配置即开发"价值
3. **技术风险**：PostgREST 已被 Supabase 大规模验证，成熟度高
4. **未来灵活性**：
   - Phase 1（MVP）：PostgREST 唯一选项
   - Phase 2（6 个月）：开发自建 ORM 作为可选项
   - Phase 3（12 个月）：用户可选择 PostgREST 或 ORM

**权衡接受**：
- ✅ 接受：MVP 阶段依赖 PostgREST 外部项目
- ✅ 接受：复杂业务逻辑需要通过函数服务或工作流实现
- ✅ 接受：未来可能需要开发自建 ORM（长期投资）
- ❌ 拒绝：MVP 阶段自建 ORM（时间成本过高，延误上市）

**技术实现**：

```yaml
# apprun.yml - MVP 配置
data:
  engine: postgrest  # MVP 唯一选项
  connection:
    host: postgres
    database: apprun
    
models:
  Server:
    fields:
      name: string
      ip: string
    # PostgREST 自动生成：
    # GET    /api/servers
    # POST   /api/servers
    # PATCH  /api/servers/:id
    # DELETE /api/servers/:id
```

**未来扩展路径**：

```yaml
# apprun.yml - Phase 2 配置
data:
  engine: orm  # 或 postgrest
  features:
    - hooks       # ORM 专属
    - validation  # ORM 专属
    - cache       # ORM 专属
```

**验证指标**：
- PostgREST 集成时间 < 1 周
- CRUD API 自动生成成功率 100%
- API 响应时间 P95 < 200ms
- 复杂查询支持度 > 90%（关联、过滤、分页）

**降级方案**：
- 如果 PostgREST 性能或功能不满足需求，立即启动 ORM 开发
- 目标：6 个月内完成 ORM 作为备选方案

---

### ADR 总结：决策原则与模式

通过以上 5 个关键架构决策记录，我们提炼出 apprun 的**架构决策原则**：

#### 核心决策原则

1. **轻量级优先原则**
   - 每个决策都要评估对"1GB 内存 + 20s 启动"目标的影响
   - 示例：选择 Go 单语言栈、NATS 而非 Kafka

2. **渐进式复杂度原则**
   - 简单场景零代码，复杂场景完全灵活
   - 示例：配置 DSL + 代码扩展、PostgREST + 未来 ORM

3. **用户价值驱动原则**
   - MVP 优先验证核心价值（95% 时间节省）
   - 示例：PostgREST 快速验证 vs 自建 ORM 长期投资

4. **风险对冲原则**
   - 关键决策保留降级路径和替代方案
   - 示例：双引擎可降级为单一 Temporal、PostgREST 可替换为 ORM

5. **务实平衡原则**
   - 拒绝极端方案，选择平衡的混合架构
   - 示例：单容器 vs 微服务 → 混合架构

#### 决策模式总结

| 决策领域 | 极端方案 A | 极端方案 B | **平衡方案（选择）** |
|---------|-----------|-----------|-------------------|
| **部署架构** | 完全单容器 | 完全微服务 | **混合架构**（核心合并+重服务独立） |
| **事件驱动** | 仅 NATS | 仅 Temporal | **双引擎协同**（NATS 指令+Temporal 执行） |
| **开发范式** | 纯代码 | 纯可视化 | **DSL + 代码扩展**（渐进式复杂度） |
| **语言栈** | 纯 Go | 多语言 | **核心 Go + 函数多语言**（边界清晰） |
| **数据层** | PostgREST | 自建 ORM | **MVP PostgREST + 保留 ORM 路径**（快速验证） |

#### 架构哲学

apprun 的架构决策体现了一种**务实创新主义**：

- ✅ **不盲目追求极简**：单一组件无法满足复杂需求
- ✅ **不盲目追求灵活**：完全微服务牺牲轻量级目标
- ✅ **不盲目追求自主**：成熟开源组件加速 MVP
- ✅ **追求平衡与克制**：每个决策都有明确的权衡和边界

这些架构决策记录不仅是技术文档，更是 apprun **设计哲学的具象化**，为后续架构演进提供了清晰的指导原则。

---

## Developer Tool 技术规格

> **项目类型**：Developer Tool / BaaS Platform  
> **目标用户**：企业后端开发者、架构师、DevOps 工程师

### 语言支持矩阵

#### 核心平台语言

**apprun 核心平台**：100% Go 语言实现
- **理由**：轻量级目标（1GB 内存 + 20s 启动）
- **优势**：
  - 单一技术栈，降低维护成本
  - Go 编译后无运行时依赖
  - 高性能、低资源占用
  - 强大的并发支持

**技术边界**：
- ✅ 所有核心模块（认证、网关、数据、实时推送、事件中心、i18n、日志）均为 Go 实现
- ✅ Temporal 工作流引擎：Go SDK 集成
- ✅ NATS 事件中心：Go 原生客户端

#### 用户扩展开发语言支持

**工作流节点开发**：支持 Go + Python + Node.js

| 语言 | 支持方式 | 典型场景 | 执行方式 |
|------|---------|---------|---------|
| **Go** | 原生支持（推荐） | 高性能节点、数据库操作、HTTP 调用 | 进程内调用 |
| **Python** | Docker 容器 | 数据处理、AI/ML、科学计算 | 容器隔离 |
| **Node.js** | Docker 容器 | 前端集成、npm 生态、实时处理 | 容器隔离 |

**函数服务**：支持 Go + Python + Node.js

| 语言 | 冷启动时间 | 内存占用 | 适用场景 |
|------|----------|---------|---------|
| **Go** | < 100ms | 10-50MB | 高性能业务逻辑、API 处理 |
| **Python** | < 2s | 50-200MB | 数据处理、脚本任务、AI 推理 |
| **Node.js** | < 1.5s | 30-150MB | 前端 BFF、实时处理、快速开发 |

**技术实现**：
```yaml
# 工作流节点示例
workflows:
  - name: data-processing
    steps:
      - goNode:        # Go 原生节点
          type: go
          package: ./nodes/transform
      - pythonNode:    # Python 容器节点
          type: python
          image: python:3.11-slim
          script: ./scripts/analyze.py
      - nodeNode:      # Node.js 容器节点
          type: nodejs
          image: node:18-alpine
          script: ./scripts/notify.js

# 函数服务示例
functions:
  - name: imageProcessing
    runtime: python
    handler: handler.process
    source: ./functions/image.py
  - name: webhookHandler
    runtime: go
    handler: main.Handle
    source: ./functions/webhook.go
```

**不支持的语言**（MVP 阶段）：
- ❌ Java/Kotlin（运行时重量级，违背轻量化原则）
- ❌ Ruby/PHP（企业开发者占比低，优先级低）
- ❌ Rust（学习曲线高，社区规模小）

**未来扩展路径**（6-12 个月）：
- 支持 WASM 运行时（跨语言、高性能）
- 插件系统支持任意语言（通过 gRPC/HTTP 协议）

---

### 安装与部署方式

#### 部署架构

**apprun 不提供单一二进制文件**

**技术原因**：
- apprun 是 **10 个核心模块的集成平台**，无法编译为单一二进制
- 依赖外部服务：PostgreSQL、Temporal Server、NATS Server
- 需要配置文件、模板文件、静态资源等运行时资源

**正确理解**：
- ❌ 错误：apprun = 单个可执行文件
- ✅ 正确：apprun = 容器化的微服务平台

#### MVP 阶段支持的安装方式

**方式 1：Docker 容器部署（推荐 - 开发环境）**

```bash
# 单命令启动 apprun 开发环境
docker run -d \
  -p 8080:8080 \
  -v ./config:/etc/apprun \
  -e DATABASE_URL=postgres://... \
  apprun/apprun:latest

# 启动时间：< 20s
# 内存占用：< 1GB
```

**方式 2：Docker Compose 部署（推荐 - 生产环境）**

```yaml
# docker-compose.yml
version: '3.8'
services:
  apprun-core:
    image: apprun/core:latest
    environment:
      - MODULES=auth,gateway,data,realtime,events,i18n,logs
    depends_on:
      - postgres
      - temporal
      - nats
  
  temporal:
    image: temporalio/auto-setup:latest
  
  nats:
    image: nats:alpine
  
  postgres:
    image: postgres:14

# 启动命令
docker-compose up -d
```

**不支持的方式**（MVP 阶段）：
- ❌ 二进制下载（技术上不可行）
- ❌ 包管理器安装（apt, brew, yum）- 复杂度高，优先级低
- ❌ Kubernetes Helm Chart - MVP 后考虑
- ❌ 云服务 SaaS 版本 - 长期规划

**部署时间对比**：

| 方式 | 启动时间 | 配置复杂度 | 适用场景 |
|------|---------|-----------|---------|
| Docker 单容器 | < 20s | 低 | 本地开发、快速验证 |
| Docker Compose | < 60s | 中 | 生产部署、完整测试 |

---

### API 接口设计

#### API 层级架构

apprun 对外暴露 **3 个层级的 API**：

**层级 1：用户业务 API（自动生成）**

基于数据模型配置自动生成的 CRUD API：

```yaml
# 配置
models:
  Server:
    fields: { name: string, ip: string }

# 自动生成的 API
GET    /api/servers          # 查询列表
POST   /api/servers          # 创建
GET    /api/servers/:id      # 查询详情
PATCH  /api/servers/:id      # 更新
DELETE /api/servers/:id      # 删除
```

**特性**：
- RESTful 标准设计
- 自动分页、排序、过滤
- 认证和权限自动集成
- OpenAPI 规范文档自动生成

**层级 2：平台管理 API（优先实现）**

管理 apprun 平台本身的 API：

**租户管理 API**：
```
POST   /admin/tenants                 # 创建租户
GET    /admin/tenants                 # 查询租户列表
GET    /admin/tenants/:id             # 查询租户详情
PATCH  /admin/tenants/:id             # 更新租户配置
DELETE /admin/tenants/:id             # 删除租户
PUT    /admin/tenants/:id/quota       # 设置资源配额
```

**配置管理 API**：
```
GET    /admin/config                  # 查询平台配置
PATCH  /admin/config                  # 更新平台配置
POST   /admin/config/reload           # 重新加载配置
```

**监控查询 API**：
```
GET    /admin/health                  # 健康检查
GET    /admin/metrics                 # 性能指标
GET    /admin/logs                    # 日志查询
POST   /admin/logs/query              # 高级日志查询
GET    /admin/events                  # 事件追踪
```

**用户管理 API**：
```
POST   /admin/users                   # 创建用户
GET    /admin/users                   # 查询用户列表
PATCH  /admin/users/:id               # 更新用户
DELETE /admin/users/:id               # 删除用户
PUT    /admin/users/:id/roles         # 分配角色
```

**权限管理 API**：
```
GET    /admin/roles                   # 查询角色列表
POST   /admin/roles                   # 创建角色
PATCH  /admin/roles/:id               # 更新角色
DELETE /admin/roles/:id               # 删除角色
PUT    /admin/roles/:id/permissions   # 分配权限
```

**MVP 优先级**：
- ✅ **必需**：租户管理、配置管理、健康检查
- ✅ **必需**：基础监控查询（日志、指标）
- ⚠️ **次要**：高级日志查询、事件追踪（功能简化）
- ⏳ **延后**：用户管理、权限管理（可通过数据模型 API 实现）

**层级 3：扩展开发 API（部分支持）**

供开发者扩展 apprun 功能的 API：

**工作流节点开发接口**：
```go
// Go SDK 示例
package nodes

import "github.com/websoft9/apprun/workflow"

type CustomNode struct {
    workflow.BaseNode
}

func (n *CustomNode) Execute(ctx workflow.Context, input interface{}) (interface{}, error) {
    // 自定义节点逻辑
    return result, nil
}

// 注册节点
func init() {
    workflow.RegisterNode("customNode", &CustomNode{})
}
```

**函数服务开发接口**：
```go
// Go 函数示例
package main

import "github.com/websoft9/apprun/function"

func Handler(ctx function.Context, event function.Event) (function.Response, error) {
    // 业务逻辑
    return function.Response{
        StatusCode: 200,
        Body:       result,
    }, nil
}
```

**插件系统接口**（MVP 暂不支持）：
- 延后到 Phase 2（6 个月后）
- 基于 gRPC 或 HTTP 协议的插件机制

---

### 文档与示例

#### MVP 阶段文档规划（3 个月）

**必需文档（高优先级）**：

**1. API 文档**

- **OpenAPI 规范文档**（自动生成）
  - 所有用户业务 API 的完整规范
  - 平台管理 API 的完整规范
  - 交互式文档界面（Swagger UI / ReDoc）
  
- **API 快速开始**
  - 认证流程（JWT 获取和使用）
  - 典型 API 调用示例
  - 错误码参考
  - 频率限制说明

**示例 API 文档结构**：
```
/docs/api/
  ├── openapi.yaml              # OpenAPI 3.0 规范
  ├── authentication.md         # 认证指南
  ├── rate-limiting.md          # 限流说明
  ├── error-codes.md            # 错误码参考
  └── examples/                 # 代码示例
      ├── curl/
      ├── go/
      ├── python/
      └── nodejs/
```

**2. 架构指南**

- **双引擎协同架构**
  - Temporal + NATS 分工说明
  - 何时使用 Event Hub vs Temporal
  - 事件命名规范和最佳实践
  - Fire-and-Forget 模式详解
  
- **配置 DSL 最佳实践**
  - 数据模型配置完整指南
  - 实时推送配置指南
  - 工作流 DSL 编写规范
  - 渐进式复杂度示例
  
- **轻量级部署架构**
  - 核心服务合并策略
  - 独立服务部署指南
  - 资源占用优化技巧
  - 水平扩展方案

**示例架构指南结构**：
```
/docs/architecture/
  ├── dual-engine.md            # 双引擎架构
  ├── configuration-dsl.md      # 配置 DSL 指南
  ├── deployment.md             # 部署架构
  ├── scaling.md                # 扩展策略
  └── best-practices.md         # 最佳实践
```

**次要文档（中优先级 - MVP 可选）**：

- **快速开始教程**：5 分钟上手（可简化为 README）
- **完整示例项目**：1-2 个典型场景（优先 1 个）
- **故障排查指南**：常见问题和解决方案
- **性能调优指南**：生产环境优化建议

**延后文档（低优先级 - MVP 后）**：

- 迁移指南（从 Supabase/Spring Boot 迁移）
- 高级特性文档（多租户、RBAC 矩阵）
- 插件开发指南
- 贡献者指南

#### 示例项目规划

**MVP 必需示例**（至少 1 个）：

**示例 1：服务器管理系统**（推荐优先实现）
- **场景**：企业内部运维系统
- **覆盖功能**：
  - 数据模型配置（Server 实体）
  - 自动 CRUD API 生成
  - 认证和权限集成
  - 实时推送（服务器状态更新）
  - 简单工作流（服务器健康检查任务）
- **代码量**：< 200 行 YAML 配置
- **价值展示**：95% 时间节省

**示例 2：订单处理系统**（可选）
- **场景**：电商订单工作流
- **覆盖功能**：
  - 复杂工作流（订单 → 库存 → 支付 → 物流）
  - Event Hub + Temporal 协同
  - 多步骤业务编排
  - 重试和补偿机制
- **代码量**：< 300 行 YAML + 少量 Go 函数
- **价值展示**：事件驱动架构最佳实践

**示例 3：多租户 SaaS 应用**（延后）
- Phase 2 实现（6 个月后）

---

### CLI 工具设计

#### CLI 工具优先级（MVP 阶段投入重点）

**核心命令**（MVP 必需）：

**1. `apprun init` - 项目初始化**

```bash
# 创建新项目
apprun init my-project

# 输出：
# ✓ Created project directory: my-project/
# ✓ Generated config/apprun.yml
# ✓ Generated config/models.yml
# ✓ Generated docker-compose.yml
# ✓ Next: cd my-project && apprun dev
```

**功能**：
- 生成项目目录结构
- 创建默认配置文件
- 生成 Docker Compose 配置
- 提供快速开始指引

**2. `apprun dev` - 本地开发模式**

```bash
# 启动开发环境
apprun dev

# 输出：
# Starting apprun development environment...
# ✓ PostgreSQL ready on :5432
# ✓ Temporal ready on :7233
# ✓ NATS ready on :4222
# ✓ apprun core ready on :8080
# 
# 📚 API Docs: http://localhost:8080/docs
# 🔍 Logs: apprun logs --follow
# ⚡ Hot reload enabled
```

**功能**：
- 自动启动所有依赖服务（PostgreSQL, Temporal, NATS）
- 启动 apprun 核心服务
- 配置文件热重载
- 实时日志输出
- 自动打开 API 文档

**3. `apprun logs` - 日志查看**

```bash
# 查看所有日志
apprun logs

# 实时跟踪日志
apprun logs --follow

# 过滤特定服务
apprun logs --service=workflow

# 搜索日志
apprun logs --grep="error"

# 查看最近 N 行
apprun logs --tail=100
```

**功能**：
- 集中式日志查询
- 实时日志流
- 服务过滤
- 关键词搜索
- 时间范围过滤

**4. `apprun config` - 配置管理**

```bash
# 验证配置文件
apprun config validate

# 查看当前配置
apprun config show

# 重新加载配置（无需重启）
apprun config reload
```

**功能**：
- YAML 配置验证
- 配置查看和导出
- 热重载配置

**5. `apprun status` - 状态检查**

```bash
# 查看服务状态
apprun status

# 输出：
# apprun Status Report
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# Service          Status    Uptime     Memory
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# Core             ✓ Up      2h 15m     512MB
# PostgreSQL       ✓ Up      2h 15m     128MB
# Temporal         ✓ Up      2h 15m     256MB
# NATS             ✓ Up      2h 15m     64MB
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# Total Memory: 960MB / 1GB
```

**功能**：
- 所有服务健康检查
- 运行时间统计
- 内存占用监控
- 快速故障诊断

**次要命令**（MVP 可选）：

**6. `apprun stop` / `apprun restart`** - 服务控制
**7. `apprun db` - 数据库管理**
```bash
apprun db migrate   # 运行数据迁移
apprun db seed      # 导入种子数据
apprun db reset     # 重置数据库
```

**延后命令**（Phase 2）：

- `apprun deploy` - 部署到生产
- `apprun scale` - 水平扩展
- `apprun backup` / `apprun restore` - 备份恢复
- `apprun plugin` - 插件管理

#### CLI 工具技术实现

**技术栈**：
- Go 编译的独立二进制文件
- 使用 Cobra CLI 框架
- 支持 Linux / macOS / Windows

**安装方式**：
```bash
# 通过 Docker 内置
docker run apprun/apprun:latest apprun --help

# 或独立安装 CLI 工具
curl -sSL https://get.apprun.io | sh
```

---

### 版本管理策略

#### 语义化版本（Semantic Versioning）

apprun 采用 **Semantic Versioning 2.0.0** 标准：

**版本格式**：`MAJOR.MINOR.PATCH`

- **MAJOR**：不兼容的 API 变更
- **MINOR**：向后兼容的功能新增
- **PATCH**：向后兼容的问题修复

**示例**：
- `1.0.0` - 首个稳定版本
- `1.1.0` - 新增功能（如新的工作流节点）
- `1.1.1` - 修复 Bug
- `2.0.0` - API 破坏性变更

#### 配置文件版本管理

**配置文件不需要版本标识**

**设计原则**：
- ✅ **隐式版本**：apprun 根据运行的版本自动解析配置
- ✅ **向后兼容**：新版本 apprun 必须能解析旧版本配置
- ✅ **渐进弃用**：废弃的配置项保留 2 个 MAJOR 版本

**示例**：
```yaml
# 无需显式版本标识
# apprun 1.0 的配置
models:
  Server:
    fields: { name: string }

# apprun 1.5 新增功能，但旧配置仍然有效
models:
  Server:
    fields: { name: string }
    indexes: [name]  # 新功能

# apprun 2.0 重命名字段，但保留兼容性
models:
  Server:
    # 旧写法仍然支持（内部自动转换）
    fields: { name: string }
    
    # 新写法（推荐）
    schema:
      properties: { name: { type: string } }
```

**弃用警告机制**：
```bash
# 启动时警告
⚠️  DEPRECATION WARNING:
    Configuration key 'fields' is deprecated since v1.8.0
    Use 'schema.properties' instead
    Support will be removed in v3.0.0
    See: https://docs.apprun.io/migration/v3
```

#### API 向后兼容策略

**用户业务 API**：
- ✅ **完全兼容**：CRUD API 结构不变
- ✅ **版本无关**：无需在 URL 中指定版本（如 `/v1/api`）
- ✅ **扩展性保证**：新增字段不破坏现有客户端

**平台管理 API**：
- ✅ **向后兼容**：保证 MINOR 版本内兼容
- ⚠️ **MAJOR 变更**：允许 API 结构调整（提前 3 个月通知）
- ✅ **弃用机制**：废弃的 API 保留至少 1 年

**API 兼容性示例**：
```
# apprun 1.0.0
GET /admin/tenants
Response: { "tenants": [...] }

# apprun 1.5.0 - 向后兼容，新增字段
GET /admin/tenants
Response: { 
  "tenants": [...],
  "pagination": { "total": 10 }  # 新增
}

# apprun 2.0.0 - 破坏性变更
GET /admin/tenants?page=1&size=10  # URL 参数变更
Response: {
  "data": [...],      # 字段重命名
  "meta": { ... }     # 结构调整
}
```

#### 数据迁移策略

**自动迁移机制**：
```bash
# apprun 启动时自动检测数据库版本
apprun dev

# 输出：
# Checking database schema...
# Current version: 1.0.5
# Target version:  1.2.0
# Running migrations:
#   ✓ 001_add_indexes.sql
#   ✓ 002_add_tenant_quota.sql
# Database migration completed successfully
```

**手动迁移控制**（可选）：
```bash
# 禁用自动迁移
apprun dev --no-auto-migrate

# 手动运行迁移
apprun db migrate

# 回滚迁移
apprun db migrate --rollback
```

**迁移文件管理**：
```
/migrations/
  ├── 001_initial_schema.up.sql
  ├── 001_initial_schema.down.sql
  ├── 002_add_tenant_quota.up.sql
  ├── 002_add_tenant_quota.down.sql
```

#### 升级路径

**MINOR 版本升级**（如 1.0 → 1.5）：
1. 停止 apprun 服务
2. 拉取新镜像：`docker pull apprun/apprun:1.5.0`
3. 启动服务（自动迁移）：`docker-compose up -d`
4. 验证：`apprun status`

**MAJOR 版本升级**（如 1.x → 2.0）：
1. 阅读迁移指南：`https://docs.apprun.io/migration/v2`
2. 备份数据库：`apprun db backup`
3. 更新配置文件（处理破坏性变更）
4. 测试环境验证
5. 生产环境升级

**回滚策略**：
- 保留前 3 个版本的镜像
- 数据库迁移支持回滚
- 配置文件版本控制（Git）

---

### Developer Tool 技术规格总结

#### MVP 阶段关键决策

| 维度 | 决策 | 理由 |
|------|------|------|
| **语言支持** | Go + Python + Node.js | 覆盖 80% 企业开发者 |
| **部署方式** | Docker 容器（不支持单一二进制） | 技术架构决定（10 模块集成平台） |
| **API 设计** | 3 层级（业务 + 管理 + 扩展） | 平台管理 API 优先实现 |
| **文档规划** | API 文档 + 架构指南 | MVP 核心价值验证 |
| **CLI 工具** | 5 个核心命令 | 开发体验优先投入 |
| **版本策略** | 语义化版本 + 向后兼容 | 配置文件无需版本标识 |

#### 技术价值主张

作为 Developer Tool，apprun 的核心价值：

1. ✅ **快速上手**：5 分钟从安装到第一个 API 调用
2. ✅ **配置驱动**：YAML 配置自动生成 95% 功能
3. ✅ **多语言友好**：Go/Python/Node.js 扩展开发
4. ✅ **开发体验优先**：CLI 工具 + API 文档 + 架构指南
5. ✅ **向后兼容保证**：平滑升级路径，无破坏性变更担忧

#### 与传统方案对比

| 维度 | Spring Boot | Supabase | apprun |
|------|------------|----------|--------|
| **语言支持** | Java 为主 | JS/TS | Go + Python + Node |
| **部署方式** | JAR 单文件 | 8-12 容器 | 1-6 容器 |
| **开发范式** | 代码为主 | SQL + JS | 配置为主 + 代码扩展 |
| **平台管理** | 需自建 | Web 控制台 | **CLI + API（MVP 重点）** |
| **文档质量** | 社区驱动 | 官方完善 | **API + 架构（MVP 聚焦）** |
| **版本管理** | Maven/Gradle | SaaS 无感 | **语义化 + 向后兼容** |

apprun 在 **开发者体验** 和 **轻量级企业级平衡** 上形成独特竞争力。

---

## 项目范围与阶段规划

### MVP 战略定位

#### MVP 哲学：平台型 MVP（Platform MVP）

**战略选择**：构建扩展基础，核心模块完整，高级功能后续添加

**选择理由**：
1. ✅ **完整价值展示**：10 大核心模块全部实现（功能简化但架构完整）
2. ✅ **扩展性基础**：工作流节点、函数服务的扩展机制从 MVP 开始支持
3. ✅ **快速迭代能力**：平台架构到位，后续功能可快速叠加
4. ✅ **用户信心建立**：完整的"轻量级 BaaS"体验，而非"半成品"

**核心目标**：
- 🎯 3 个月交付功能完备的轻量级开发框架
- 🎯 验证"配置即开发"核心价值（95% 时间节省）
- 🎯 至少 3 个内部团队采用并给出正面反馈
- 🎯 轻量级目标达成（≤ 1GB 内存、≤ 20s 启动）

---

### MVP 核心功能集（Phase 1 - 3 个月）

#### 必需核心模块（完整实现）

**1. 认证与权限（Authentication & Authorization）**

**功能范围**：
- ✅ JWT 令牌生成和验证
- ✅ RBAC 基础权限模型（角色、权限、资源）
- ✅ 用户注册、登录、登出
- ✅ 密码加密存储（bcrypt）
- ✅ 基础用户管理 API

**技术实现**：
- Go 标准库 + JWT 库（golang-jwt）
- PostgreSQL 存储用户和权限数据
- 与 API 网关深度集成

**不包含（MVP）**：
- ❌ OAuth2/OIDC 第三方登录
- ❌ 多因素认证（MFA）
- ❌ SSO 单点登录
- ❌ 细粒度字段级权限

**验收标准**：
- 用户可通过 API 注册、登录
- JWT 令牌正确验证和过期管理
- RBAC 权限检查在 API 层生效
- 响应时间 < 50ms（认证检查）

---

**2. API 网关（API Gateway）**

**功能范围**：
- ✅ HTTP 请求路由和转发
- ✅ 统一认证和权限检查（集成认证模块）
- ✅ 基础请求/响应日志记录
- ✅ CORS 跨域支持
- ✅ 基础错误处理和标准化响应

**技术实现**：
- Go 标准库 `net/http` + Chi 路由框架
- 中间件架构（认证、日志、错误处理）
- 反向代理到后端服务

**不包含（MVP）**：
- ❌ 限流和速率控制
- ❌ 服务发现和负载均衡
- ❌ 熔断降级
- ❌ 灰度发布和 A/B 测试
- ❌ API 版本管理

**验收标准**：
- 所有 API 请求通过统一网关
- 认证失败请求正确拦截（401）
- 权限不足请求正确拦截（403）
- 路由性能 < 5ms（网关层开销）

---

**3. 数据模型与自动 API（Data Model & Auto CRUD）**

**功能范围**：
- ✅ YAML 配置化数据模型定义
- ✅ 基于 PostgREST 的自动 CRUD API 生成
- ✅ 标准 RESTful 接口（GET/POST/PATCH/DELETE）
- ✅ 基础查询功能（分页、排序、过滤）
- ✅ 数据验证（类型、必填、格式）
- ✅ 关联查询（基础外键关系）

**技术实现**：
- PostgREST 集成（MVP 阶段唯一选项）
- PostgreSQL 作为数据存储
- YAML 配置解析和 Schema 生成

**配置示例**：
```yaml
models:
  Server:
    fields:
      name: 
        type: string
        required: true
      ip_address: 
        type: string
        pattern: '^(\d{1,3}\.){3}\d{1,3}$'
      status: 
        type: enum
        values: [active, inactive, maintenance]
      created_at: 
        type: timestamp
        auto: true
    auth: jwt
    permissions:
      read: [admin, operator]
      write: [admin]
```

**不包含（MVP）**：
- ❌ 自建 ORM（延后到 Phase 2）
- ❌ 复杂关联查询（多层嵌套）
- ❌ 全文搜索
- ❌ 数据聚合和统计查询
- ❌ 实时数据订阅（Subscriptions）

**验收标准**：
- 配置模型后自动生成完整 CRUD API
- API 响应时间 P95 < 200ms
- 数据验证错误正确返回（400）
- 支持至少 1000 条记录的分页查询

---

#### 简化核心模块（基础功能）

**4. 函数计算（Function Service）**

**战略定位**：**个性化业务问题的解决方案**

**核心价值验证**：
- ✅ 证明 apprun 不是"配置死板的框架"
- ✅ 展示"配置 + 代码"的渐进式复杂度
- ✅ 解决"配置无法覆盖的 5% 复杂场景"

**功能范围（简化）**：
- ✅ Go 函数原生支持（进程内调用）
- ✅ HTTP 触发器（API 端点绑定）
- ✅ 基础函数部署和热重载
- ✅ 与数据模型和认证的集成

**技术实现**：
```yaml
# 函数配置示例
functions:
  - name: customValidation
    runtime: go
    handler: validation.ValidateServer
    trigger:
      type: http
      path: /api/validate-server
      method: POST
    auth: jwt
```

```go
// Go 函数实现
package validation

import "github.com/websoft9/apprun/function"

func ValidateServer(ctx function.Context, req function.Request) (function.Response, error) {
    // 自定义业务逻辑
    server := req.Body["server"]
    
    // 调用外部 API、复杂计算、特殊验证等
    if !isValidServerConfig(server) {
        return function.Response{
            StatusCode: 400,
            Body: map[string]string{"error": "Invalid server config"},
        }, nil
    }
    
    return function.Response{
        StatusCode: 200,
        Body: map[string]string{"message": "Validation passed"},
    }, nil
}
```

**不包含（MVP）**：
- ❌ Python/Node.js 容器运行时（延后到 Phase 2）
- ❌ 定时触发器（Cron）
- ❌ 事件触发器（Event Hub 集成）
- ❌ 函数版本管理和回滚
- ❌ 冷启动优化和预热

**验收标准**：
- Go 函数可通过 HTTP 触发
- 函数冷启动时间 < 100ms
- 函数可访问数据库和认证上下文
- 至少支持 3 个典型业务场景（验证、转换、通知）

**MVP 价值**：
- ✅ 展示 apprun 的灵活性："配置覆盖 95%，代码解决 5%"
- ✅ 解决试点团队的个性化需求
- ✅ 为 Phase 2 的多语言支持打下基础

---

**5. 实时推送（Realtime Push）**

**功能范围（简化）**：
- ✅ WebSocket 服务端推送能力
- ✅ 基础连接管理（连接、断开、心跳）
- ✅ 指定 API 路径启用实时推送
- ✅ 服务端主动推送消息到客户端

**技术实现**：
```yaml
# 实时推送配置
realtime:
  paths:
    - /api/servers/status       # 服务器状态实时推送
    - /api/deployments/progress # 部署进度实时推送
```

```go
// 服务端推送示例
func UpdateServerStatus(serverID string, status string) {
    apprun.Realtime.Publish("/api/servers/status", map[string]interface{}{
        "server_id": serverID,
        "status":    status,
        "timestamp": time.Now(),
    })
}
```

**不包含（MVP）**：
- ❌ 房间/频道管理
- ❌ 消息持久化和历史查询
- ❌ 送达确认和消息重传
- ❌ 客户端间通信（P2P）
- ❌ 高级订阅过滤（基于条件的推送）

**验收标准**：
- WebSocket 连接成功建立
- 服务端消息实时推送到客户端（延迟 < 100ms）
- 单实例支持 1000+ 并发连接
- 连接断开后自动清理资源

---

**6. 工作流引擎（Workflow Engine - Temporal）**

**功能范围（简化）**：
- ✅ Temporal 集成和基础配置
- ✅ 简单工作流定义（YAML 配置）
- ✅ 事件触发工作流（Event Hub 集成）
- ✅ 基础节点：HTTP 调用、数据库操作、延迟
- ✅ 工作流状态查询和日志

**技术实现**：
```yaml
# 工作流配置示例
workflows:
  - name: server-onboarding
    trigger:
      type: event
      event: server.created
    steps:
      - sendNotification:
          type: http
          url: https://notification-service/send
          method: POST
          body:
            message: "New server created: {{event.server.name}}"
      - delay:
          duration: 5m
      - healthCheck:
          type: http
          url: "http://{{event.server.ip}}/health"
          retry: 3
```

**不包含（MVP）**：
- ❌ 可视化工作流设计器
- ❌ 复杂条件分支和循环
- ❌ 人工审批节点
- ❌ 工作流版本管理
- ❌ Saga 模式补偿机制（保留基础重试）

**验收标准**：
- 事件成功触发工作流执行
- 工作流步骤按顺序执行
- 失败步骤自动重试（最多 3 次）
- 工作流日志可查询

---

**7. 事件中心（Event Hub - NATS）**

**功能范围（简化）**：
- ✅ NATS 集成和基础配置
- ✅ 发布-订阅模式（Pub/Sub）
- ✅ 事件发布和订阅 API
- ✅ 与工作流引擎的集成（触发工作流）
- ✅ 基础事件日志记录

**技术实现**：
```go
// 发布事件
apprun.EventHub.Publish("server.created", ServerEvent{
    ServerID: "srv-001",
    Name:     "web-server-1",
    IP:       "192.168.1.100",
})

// 订阅事件
apprun.EventHub.Subscribe("server.created", func(event ServerEvent) {
    log.Info("Server created: ", event.Name)
    // 触发工作流或发送通知
})
```

**不包含（MVP）**：
- ❌ 事件持久化和重放
- ❌ 死信队列（DLQ）
- ❌ 事件流式处理（Stream）
- ❌ 复杂事件模式匹配
- ❌ 事件版本管理

**验收标准**：
- 事件发布成功率 > 99%
- 事件延迟 P95 < 50ms
- 订阅者正确接收事件
- 支持至少 1000 msg/s 吞吐量（MVP 基准）

---

**8. 日志与监控（Logging & Monitoring）**

**功能范围（简化）**：
- ✅ 集中式日志收集（所有模块日志统一）
- ✅ 基础日志查询 API（时间范围、关键词搜索）
- ✅ 健康检查端点（/health）
- ✅ 基础性能指标（CPU、内存、请求数）
- ✅ 简单告警（基于阈值）

**技术实现**：
- 使用标准日志库（zerolog）
- PostgreSQL 存储日志（MVP 简化方案）
- Prometheus 格式的 metrics 端点

**不包含（MVP）**：
- ❌ 分布式追踪（OpenTelemetry）
- ❌ 日志分析和可视化 Dashboard
- ❌ 复杂告警规则和通知渠道
- ❌ 日志归档和压缩

**验收标准**：
- 所有模块日志统一收集
- 日志查询响应时间 < 1s
- 健康检查端点正常工作
- 基础指标正确暴露（Prometheus 格式）

---

#### 延后模块（Phase 2+）

**9. 存储服务（Storage Service）**

**延后理由**：
- 非核心价值验证必需
- 可通过外部对象存储服务（MinIO/S3）临时替代
- MVP 阶段业务场景不强依赖文件存储

**Phase 2 规划**（6 个月后）：
- 轻量级对象存储实现
- 文件上传和下载 API
- 图片处理（缩放、裁剪）

---

**10. 国际化（i18n）**

**延后理由**：
- 内部平台优先中文支持
- 试点阶段无多语言需求
- 可通过函数计算临时实现简单翻译

**Phase 2 规划**（6 个月后）：
- 多语言内容管理
- 翻译 API 集成
- 语言切换和本地化

---

### 资源配置与约束

#### 团队配置（MVP - 3 个月）

**核心团队**：
- **后端开发者**：2 人（基于 Vibe Coding 高效协作）
- **DevOps 工程师**：1 人（部署、基础设施、CI/CD）
- **前端开发**：0 人（MVP 阶段不开发管理控制台，仅 API + CLI）

**团队结构**：
```
开发者 A（技术负责人）
  ├─ 核心架构设计
  ├─ 认证+权限模块
  ├─ API 网关模块
  └─ 数据模型+PostgREST 集成

开发者 B（功能实现）
  ├─ 函数计算模块
  ├─ 实时推送模块
  ├─ 工作流引擎集成
  └─ 事件中心集成

DevOps 工程师
  ├─ Docker 容器化
  ├─ CI/CD 流水线
  ├─ 日志监控基础设施
  └─ 部署文档和脚本
```

**技能要求**：
- ✅ Go 语言精通（后端开发者）
- ✅ PostgreSQL 熟练（后端开发者）
- ✅ Temporal 基础（开发者 B）
- ✅ NATS 基础（开发者 B）
- ✅ Docker 精通（DevOps）
- ✅ 技术文档写作（全员）

**Vibe Coding 优势**：
- AI 辅助快速原型开发
- 代码审查和优化建议
- 自动化测试用例生成
- 文档和注释自动生成

**预计生产力提升**：
- 2 人团队 ≈ 传统 3-4 人团队效率
- 3 个月交付 ≈ 传统 4-6 个月工作量

---

#### 时间线规划（3 个月硬性要求）

**Month 1：核心基础（Week 1-4）**

**Week 1-2：架构搭建与核心模块**
- ✅ 项目初始化和 Docker 容器化
- ✅ PostgreSQL + Temporal + NATS 集成
- ✅ 认证与权限模块（JWT + RBAC）
- ✅ API 网关基础框架
- **里程碑**：用户可注册、登录并获取 JWT

**Week 3-4：数据模型与自动 API**
- ✅ YAML 配置解析器
- ✅ PostgREST 集成
- ✅ 自动 CRUD API 生成
- ✅ 基础数据验证
- **里程碑**：配置模型后自动生成完整 API

---

**Month 2：扩展功能（Week 5-8）**

**Week 5-6：函数计算与实时推送**
- ✅ 函数计算框架（Go 原生）
- ✅ HTTP 触发器集成
- ✅ WebSocket 服务端推送
- ✅ 连接管理和心跳
- **里程碑**：Go 函数可处理业务逻辑，实时推送工作

**Week 7-8：工作流与事件中心**
- ✅ Temporal 工作流集成
- ✅ YAML 工作流配置解析
- ✅ NATS 事件中心集成
- ✅ 事件触发工作流
- **里程碑**：事件驱动架构基本可用

---

**Month 3：完善与验证（Week 9-12）**

**Week 9-10：日志监控与 CLI 工具**
- ✅ 集中式日志收集
- ✅ 健康检查和基础监控
- ✅ CLI 工具（init, dev, logs, status, config）
- ✅ 配置文件热重载
- **里程碑**：开发者体验完整

**Week 11：文档与示例**
- ✅ OpenAPI 规范文档生成
- ✅ 架构指南编写（双引擎、配置 DSL）
- ✅ 完整示例项目（服务器管理系统）
- ✅ 快速开始教程
- **里程碑**：文档完整，可供试点团队使用

**Week 12：试点部署与反馈收集**
- ✅ 3 个内部团队试点部署
- ✅ 性能测试和优化
- ✅ Bug 修复和稳定性提升
- ✅ 用户反馈收集和分析
- **最终里程碑**：MVP 交付，3 个团队认可

---

#### 技术约束与风险

**技术约束**：
- ✅ **轻量级目标**：≤ 1GB 内存、≤ 20s 启动时间（硬性要求）
- ✅ **纯后端**：MVP 不开发前端管理控制台
- ✅ **Go 单语言栈**：核心模块 100% Go 实现（降低维护成本）
- ✅ **PostgreSQL 单数据库**：简化架构，避免多存储引擎

**关键风险与缓解**：

**风险 1：Temporal/NATS 集成复杂度超预期**
- **概率**：中
- **影响**：高（核心架构组件）
- **缓解措施**：
  - Week 1 完成技术验证 POC
  - 准备降级方案：简化为单一 Temporal，牺牲部分性能
  - 提前准备技术文档和社区支持

**风险 2：PostgREST 性能或功能不满足需求**
- **概率**：中
- **影响**：高（核心数据层）
- **缓解措施**：
  - Week 3 完成性能基准测试
  - 准备降级方案：启动自建 ORM 开发（延长到 Month 4）
  - 保留 API 层抽象，底层实现可替换

**风险 3：3 个月时间不足**
- **概率**：低（基于 Vibe Coding）
- **影响**：高（项目延期）
- **缓解措施**：
  - 每周里程碑检查，及早发现延误
  - 功能优先级动态调整（存储、i18n 可彻底移除）
  - 延后非核心功能（Python/Node 函数支持）

**风险 4：轻量级目标无法达成**
- **概率**：低
- **影响**：中（核心差异化受损）
- **缓解措施**：
  - Week 4 进行首次内存占用测试
  - 模块按需加载机制（配置控制）
  - 性能优化迭代（Week 9-10）

---

### 验证标准与成功指标

#### MVP 验证标准（试点团队认可标准）

**核心价值验证**：
1. ✅ **配置即开发**：典型 CRUD 场景从 2-3 天缩短到 1-2 小时（95% 时间节省）
2. ✅ **轻量级部署**：单命令启动，20 秒内可用，内存占用 < 1GB
3. ✅ **功能完备**：可搭建完整的业务系统（服务器管理示例）
4. ✅ **扩展灵活**：函数计算解决个性化需求

**试点团队认可标准**：
- ✅ 至少 3 个团队部署 apprun 并用于实际项目
- ✅ 团队反馈"愿意继续使用并推荐给其他团队"
- ✅ 开发效率提升 ≥ 50%（自我评估）
- ✅ 核心功能稳定性：生产环境运行无重大故障（7 天连续）

**技术指标**：
- ✅ 启动时间 ≤ 20s（从容器启动到服务可用）
- ✅ 内存占用 ≤ 1GB（核心服务 + 依赖）
- ✅ API 响应时间 P95 < 200ms（简单查询）
- ✅ WebSocket 并发连接 ≥ 1000（单实例）
- ✅ 事件吞吐量 ≥ 1000 msg/s

**文档完整性**：
- ✅ OpenAPI 规范文档自动生成
- ✅ 架构指南完整（双引擎、配置 DSL、部署）
- ✅ 至少 1 个完整示例项目
- ✅ CLI 工具文档和使用指南

---

### Post-MVP 功能路线图

#### Phase 2：增强与扩展（Month 4-6）

**功能增强**：
- ✅ 函数计算支持 Python/Node.js（Docker 容器）
- ✅ 实时推送房间/频道管理
- ✅ 工作流可视化监控
- ✅ 分布式追踪（OpenTelemetry）
- ✅ 平台管理 Web 控制台（首次前端开发）

**新增模块**：
- ✅ 存储服务（轻量级对象存储）
- ✅ 国际化（i18n）模块

**性能优化**：
- ✅ 水平扩展支持
- ✅ 缓存策略（Redis 集成）
- ✅ 数据库连接池优化

**文档完善**：
- ✅ 迁移指南（从 Spring Boot/Supabase）
- ✅ 高级特性文档
- ✅ 故障排查指南

**团队扩展**：
- 新增前端开发者 1 人（管理控制台）
- 新增技术文档工程师 1 人

---

#### Phase 3：企业级能力（Month 7-12）

**企业级功能**：
- ✅ 多租户管理和隔离
- ✅ 高级 RBAC（细粒度权限）
- ✅ 审计日志和合规支持
- ✅ 高可用和灾备
- ✅ API 网关高级功能（限流、熔断、灰度发布）

**生态建设**：
- ✅ 插件市场
- ✅ 社区贡献机制
- ✅ SDK 和集成库
- ✅ 第三方服务集成

**平台化**：
- ✅ 低代码能力增强
- ✅ 工作流可视化设计器
- ✅ AI 驱动的日志分析

**目标**：
- 覆盖企业 80% 产品项目
- 累计节省 1000+ 人天
- ROI 达到 300%

---

### 范围边界与不做清单

#### MVP 明确不做（避免范围蔓延）

**功能层面**：
- ❌ 前端管理控制台（纯 API + CLI）
- ❌ 可视化工作流设计器
- ❌ OAuth2/OIDC 第三方登录
- ❌ 多租户管理（单租户模式）
- ❌ 高级 API 网关功能（限流、熔断）
- ❌ Python/Node.js 函数运行时
- ❌ 存储服务
- ❌ 国际化（i18n）

**技术层面**：
- ❌ Kubernetes Helm Chart（Docker Compose 优先）
- ❌ 云服务 SaaS 版本
- ❌ 自建 ORM（PostgREST 唯一选项）
- ❌ 分布式追踪（基础日志优先）
- ❌ 复杂事件流处理

**文档层面**：
- ❌ 视频教程
- ❌ 交互式 Playground
- ❌ 多语言文档（仅中文）

**决策原则**：
- ✅ 专注核心价值验证："配置即开发"
- ✅ 保持轻量级目标：≤ 1GB、≤ 20s
- ✅ 3 个月硬性交付：功能完备但不追求完美
- ✅ 后端优先：前端延后到 Phase 2

---

### 项目范围总结

#### 关键决策回顾

| 决策维度 | 选择 | 理由 |
|---------|------|------|
| **MVP 哲学** | 平台型 MVP | 完整架构 + 功能简化 = 快速迭代基础 |
| **核心模块** | 8 个（认证、网关、数据、函数、实时、工作流、事件、日志） | 功能完备的轻量级框架 |
| **延后模块** | 2 个（存储、i18n） | 非核心验证必需 |
| **函数计算** | 简化但必需 | 解决个性化业务问题，展示灵活性 |
| **团队规模** | 2 后端 + 1 DevOps | 基于 Vibe Coding 高效协作 |
| **时间线** | 3 个月硬性交付 | 每月清晰里程碑，风险可控 |
| **验证标准** | 3 团队认可 + 轻量级目标达成 | 实战验证核心价值 |

#### MVP 核心价值主张

apprun MVP 将证明：
1. ✅ **95% 场景配置解决**：YAML 配置自动生成 CRUD API
2. ✅ **5% 场景代码扩展**：函数计算处理个性化需求
3. ✅ **轻量级企业级平衡**：1GB 内存运行完整 BaaS 平台
4. ✅ **快速上手**：5 分钟从安装到第一个 API 调用
5. ✅ **功能完备**：可搭建真实业务系统

#### 与竞品的 MVP 对比

| 维度 | Spring Boot | Supabase | **apprun MVP** |
|------|------------|----------|----------------|
| **核心模块数** | 需自建 | 12+ | **8 个核心** |
| **配置 vs 代码** | 代码为主 | SQL + JS | **配置 95% + 代码 5%** |
| **部署复杂度** | 中（JAR） | 高（多容器） | **低（Docker Compose）** |
| **启动时间** | 10-30s | 60-120s | **≤ 20s** |
| **内存占用** | 512MB-1GB | 2-4GB | **≤ 1GB** |
| **MVP 交付时间** | 需自建（6 个月+） | 无需（SaaS） | **3 个月** |
| **个性化扩展** | 完全灵活 | 受限 | **函数计算平衡** |

apprun MVP 在 **"轻量级 + 完整性 + 灵活性"** 三者平衡上形成独特竞争力。

---

## 功能需求（Functional Requirements）

> **能力契约声明**：本节定义 apprun 产品**必须具备的所有能力**。UX 设计师、架构师、开发团队将**仅基于此清单**进行设计和实现。任何未列出的能力将不会出现在最终产品中。

### 用户认证与权限管理

**FR1**: 开发者可以为应用配置 JWT 认证机制  
**FR2**: 用户可以通过 API 注册新账户  
**FR3**: 用户可以通过 API 登录获取 JWT 令牌  
**FR4**: 用户可以通过 API 登出使令牌失效  
**FR5**: 系统可以验证 JWT 令牌的有效性和过期时间  
**FR6**: 开发者可以定义基于角色的权限模型（RBAC）  
**FR7**: 开发者可以为资源（API 端点、数据模型）配置访问权限规则  
**FR8**: 系统可以在 API 请求时自动检查用户权限  
**FR9**: 平台管理员可以创建和管理用户角色  
**FR10**: 平台管理员可以为角色分配权限  
**FR11**: 平台管理员可以为用户分配角色  

### 数据模型与 API 管理

**FR12**: 开发者可以通过 YAML 配置文件定义数据模型  
**FR13**: 开发者可以为数据模型字段指定类型（string、number、boolean、enum、timestamp）  
**FR14**: 开发者可以为字段配置验证规则（必填、格式、长度限制）  
**FR15**: 开发者可以定义数据模型之间的关联关系（外键）  
**FR16**: 系统可以根据数据模型配置自动生成 RESTful CRUD API  
**FR17**: 用户可以通过自动生成的 API 创建数据记录  
**FR18**: 用户可以通过自动生成的 API 查询数据记录列表  
**FR19**: 用户可以通过自动生成的 API 查询单条数据记录详情  
**FR20**: 用户可以通过自动生成的 API 更新数据记录  
**FR21**: 用户可以通过自动生成的 API 删除数据记录  
**FR22**: 用户可以对查询结果进行分页（指定页码和每页数量）  
**FR23**: 用户可以对查询结果进行排序（指定字段和升降序）  
**FR24**: 用户可以对查询结果进行过滤（基于字段值）  
**FR25**: 系统可以在数据操作时自动验证字段类型和格式  
**FR26**: 系统可以返回标准化的错误响应（包含错误码和描述）  
**FR27**: 系统可以自动生成 OpenAPI 规范文档  

### 函数计算与业务扩展

**FR28**: 开发者可以编写 Go 语言自定义函数处理业务逻辑  
**FR29**: 开发者可以为函数配置 HTTP 触发器（指定路径和方法）  
**FR30**: 开发者可以在函数中访问数据库连接  
**FR31**: 开发者可以在函数中访问认证上下文（当前用户信息）  
**FR32**: 用户可以通过 HTTP 端点调用自定义函数  
**FR33**: 系统可以在函数代码变更时自动热重载  
**FR34**: 系统可以记录函数执行日志  
**FR35**: 系统可以返回函数执行结果或错误信息  

### 实时数据推送

**FR36**: 开发者可以为特定 API 路径启用 WebSocket 实时推送  
**FR37**: 客户端可以建立 WebSocket 连接到指定路径  
**FR38**: 系统可以维护 WebSocket 连接心跳机制  
**FR39**: 服务端可以主动向客户端推送消息  
**FR40**: 系统可以在连接断开时自动清理资源  
**FR41**: 开发者可以在业务代码中发布实时消息到指定路径  

### 工作流与事件编排

**FR42**: 开发者可以通过 YAML 配置文件定义工作流  
**FR43**: 开发者可以为工作流配置事件触发器  
**FR44**: 开发者可以定义工作流步骤序列  
**FR45**: 开发者可以使用预定义节点（HTTP 调用、数据库操作、延迟）  
**FR46**: 系统可以在接收到事件时自动启动对应工作流  
**FR47**: 系统可以按顺序执行工作流步骤  
**FR48**: 系统可以在步骤失败时自动重试（最多 3 次）  
**FR49**: 开发者可以发布事件到事件中心  
**FR50**: 开发者可以订阅事件中心的特定事件类型  
**FR51**: 系统可以将发布的事件路由到所有订阅者  
**FR52**: 平台管理员可以查询工作流执行状态  
**FR53**: 平台管理员可以查看工作流执行日志  

### 平台管理与配置

**FR54**: 平台管理员可以创建新租户  
**FR55**: 平台管理员可以查询租户列表  
**FR56**: 平台管理员可以查看租户详情  
**FR57**: 平台管理员可以更新租户配置  
**FR58**: 平台管理员可以删除租户  
**FR59**: 平台管理员可以为租户设置资源配额  
**FR60**: 平台管理员可以查询当前平台配置  
**FR61**: 平台管理员可以更新平台配置  
**FR62**: 平台管理员可以重新加载配置而无需重启服务  
**FR63**: 开发者可以验证配置文件的正确性  
**FR64**: 系统可以检测平台健康状况  
**FR65**: 系统可以暴露性能指标（CPU、内存、请求数）  

### 开发者工具与 CLI

**FR66**: 开发者可以通过 CLI 初始化新项目（生成配置文件和目录结构）  
**FR67**: 开发者可以通过 CLI 启动本地开发环境  
**FR68**: 开发者可以通过 CLI 查看所有服务日志  
**FR69**: 开发者可以通过 CLI 实时跟踪日志输出  
**FR70**: 开发者可以通过 CLI 过滤特定服务的日志  
**FR71**: 开发者可以通过 CLI 搜索日志关键词  
**FR72**: 开发者可以通过 CLI 查看所有服务状态  
**FR73**: 开发者可以通过 CLI 查看服务资源占用（内存、运行时间）  
**FR74**: 开发者可以通过 CLI 验证配置文件  
**FR75**: 开发者可以通过 CLI 查看当前配置  
**FR76**: 开发者可以通过 CLI 重新加载配置  

### 可观测性与监控

**FR77**: 系统可以收集所有模块的日志到集中式存储  
**FR78**: 平台管理员可以通过 API 查询日志（指定时间范围）  
**FR79**: 平台管理员可以通过关键词搜索日志  
**FR80**: 系统可以提供健康检查端点  
**FR81**: 系统可以提供 Prometheus 格式的性能指标端点  
**FR82**: 平台管理员可以配置基于阈值的告警规则  
**FR83**: 系统可以在指标超过阈值时发送告警通知  

### API 网关与路由

**FR84**: 系统可以作为所有微服务的统一入口  
**FR85**: 系统可以根据请求路径路由到对应后端服务  
**FR86**: 系统可以在路由前自动验证 JWT 令牌  
**FR87**: 系统可以在路由前自动检查用户权限  
**FR88**: 系统可以记录所有 API 请求日志  
**FR89**: 系统可以支持 CORS 跨域请求  
**FR90**: 系统可以返回标准化的错误响应格式  

---

### 功能需求总结

**能力领域分布**：
- 用户认证与权限管理：11 个 FRs
- 数据模型与 API 管理：16 个 FRs
- 函数计算与业务扩展：8 个 FRs
- 实时数据推送：6 个 FRs
- 工作流与事件编排：12 个 FRs
- 平台管理与配置：12 个 FRs
- 开发者工具与 CLI：11 个 FRs
- 可观测性与监控：7 个 FRs
- API 网关与路由：7 个 FRs

**总计**：90 个功能需求

**覆盖验证**：
- ✅ MVP 8 个核心模块全部覆盖
- ✅ 用户旅程中的所有能力全部覆盖
- ✅ Developer Tool 技术规格中的能力全部覆盖
- ✅ 平台管理 API 能力全部覆盖
- ✅ CLI 工具能力全部覆盖

**实现无关性验证**：
- ✅ 所有 FRs 仅描述"能做什么"，不涉及"怎么做"
- ✅ 无 UI 细节、无性能指标、无技术选型
- ✅ 每个 FR 可通过多种方式实现
- ✅ 每个 FR 清晰可测试

**能力契约声明**：
此功能需求列表为 apprun 产品的**完整能力清单**。所有后续设计、架构和开发工作必须基于此清单进行。任何新增能力必须明确添加到此列表中，任何删减能力必须从此列表中移除并评估影响。

---

## 非功能需求（Non-Functional Requirements）

> **质量属性声明**：本节定义 apprun 系统**执行质量标准**，规定系统"做得多好"。所有质量标准均为可测试、可验证的具体指标。

### 性能（Performance）

> **战略重要性**：性能是 apprun 的核心竞争力和差异化要素（轻量级目标）

#### 启动性能

**NFR-P1**: 系统启动时间 ≤ 20 秒  
- **测量方式**：从 Docker 容器启动到服务就绪（健康检查通过）
- **验收标准**：95% 的启动实例在 20 秒内完成
- **业务价值**：快速上手体验，开发者 5 分钟从安装到 API 调用

**NFR-P2**: CLI 工具响应时间 ≤ 1 秒  
- **测量方式**：从命令输入到结果显示
- **验收标准**：常用命令（status, logs, config）响应时间 P95 < 1s
- **业务价值**：流畅的开发者体验

#### API 响应性能

**NFR-P3**: 简单查询 API 响应时间 P95 < 200ms  
- **测量方式**：从请求到达网关到响应返回（不含网络延迟）
- **验收标准**：单表查询、无复杂关联、结果集 < 100 条
- **业务价值**：用户操作无明显延迟感

**NFR-P4**: 复杂查询 API 响应时间 P95 < 1 秒  
- **测量方式**：包含关联查询、过滤、排序的 API 请求
- **验收标准**：多表关联、复杂过滤、结果集 < 1000 条
- **业务价值**：复杂业务场景可用性

**NFR-P5**: 认证检查延迟 < 50ms  
- **测量方式**：JWT 验证和权限检查耗时
- **验收标准**：API 网关层认证中间件处理时间 P95 < 50ms
- **业务价值**：认证安全不影响整体性能

#### 事件处理性能

**NFR-P6**: 事件发布延迟 < 5ms  
- **测量方式**：从代码调用发布到事件进入 NATS
- **验收标准**：P95 延迟 < 5ms
- **业务价值**：事件驱动架构的高性能保证

**NFR-P7**: 事件端到端延迟 P95 < 50ms  
- **测量方式**：从事件发布到订阅者接收
- **验收标准**：包含网络传输和序列化开销
- **业务价值**：实时性业务场景支持

**NFR-P8**: 事件吞吐量 ≥ 1,000 消息/秒  
- **测量方式**：单实例 NATS 事件中心处理能力
- **验收标准**：持续负载下稳定支持 1K msg/s
- **业务价值**：MVP 基准性能，满足中等规模企业需求

#### 工作流性能

**NFR-P9**: 工作流启动延迟 < 1 秒  
- **测量方式**：从事件触发到工作流实例创建
- **验收标准**：Temporal 工作流启动时间 P95 < 1s
- **业务价值**：事件驱动响应及时性

**NFR-P10**: 工作流步骤执行延迟 < 500ms  
- **测量方式**：单个工作流步骤（HTTP 调用、数据库操作）执行时间
- **验收标准**：不含外部服务延迟，仅 apprun 层开销 < 500ms
- **业务价值**：工作流编排效率

#### 实时推送性能

**NFR-P11**: WebSocket 消息推送延迟 < 100ms  
- **测量方式**：从服务端调用推送到客户端接收
- **验收标准**：P95 延迟 < 100ms
- **业务价值**：实时状态更新体验

**NFR-P12**: 单实例 WebSocket 并发连接数 ≥ 1,000  
- **测量方式**：单个 apprun 实例支持的活跃 WebSocket 连接
- **验收标准**：1000 并发连接下系统稳定运行
- **业务价值**：中等规模实时场景支持

#### 资源占用

**NFR-P13**: 核心服务容器内存占用 ≤ 500MB  
- **测量方式**：核心合并容器（认证+网关+数据+实时推送）稳定运行时内存
- **验收标准**：长时间运行（24 小时）内存不超过 500MB
- **业务价值**：轻量级核心目标，单机可运行多实例

**NFR-P14**: 总系统内存占用 ≤ 1GB  
- **测量方式**：所有 apprun 容器 + 依赖（PostgreSQL, Temporal, NATS）总内存
- **验收标准**：开发环境单机部署总内存 ≤ 1GB
- **业务价值**：轻量级差异化竞争力（vs Supabase 2-4GB）

**NFR-P15**: CPU 使用率正常负载 < 30%  
- **测量方式**：中等请求负载下（100 req/s）的 CPU 使用率
- **验收标准**：单核 CPU 使用率 < 30%
- **业务价值**：资源高效利用，降低运营成本

---

### 可靠性（Reliability）

> **战略重要性**：企业内部平台，生产环境稳定性直接影响业务连续性

#### 可用性

**NFR-R1**: 开发环境可用性 ≥ 95%  
- **测量方式**：服务健康检查通过时间 / 总运行时间
- **验收标准**：月度可用性 ≥ 95%
- **业务价值**：开发团队可依赖使用

**NFR-R2**: 生产环境可用性 ≥ 99%  
- **测量方式**：服务健康检查通过时间 / 总运行时间
- **验收标准**：月度可用性 ≥ 99%（允许每月 7.2 小时故障时间）
- **业务价值**：企业级可靠性标准

**NFR-R3**: 单点故障后自动恢复时间 < 60 秒  
- **测量方式**：从服务崩溃到 Docker 自动重启并就绪
- **验收标准**：95% 的故障场景在 60 秒内恢复
- **业务价值**：减少人工干预，快速恢复服务

#### 数据可靠性

**NFR-R4**: 数据持久化无丢失  
- **测量方式**：数据库事务完整性
- **验收标准**：所有已提交事务数据保证持久化
- **业务价值**：企业数据安全基础

**NFR-R5**: 工作流执行可靠性 ≥ 99.9%  
- **测量方式**：工作流成功完成率
- **验收标准**：Temporal 保证的至少一次执行（at-least-once）
- **业务价值**：关键业务流程不丢失

**NFR-R6**: 事件传递可靠性 ≥ 99%  
- **测量方式**：发布事件被订阅者成功接收的比例
- **验收标准**：NATS 至少一次交付（at-least-once delivery）
- **业务价值**：事件驱动架构可靠性基础

#### 容错能力

**NFR-R7**: API 错误率 < 0.1%  
- **测量方式**：系统错误（5xx）/ 总请求数
- **验收标准**：非业务逻辑错误的系统级故障 < 0.1%
- **业务价值**：高质量服务体验

**NFR-R8**: 工作流步骤失败自动重试  
- **测量方式**：步骤失败后自动重试机制生效
- **验收标准**：最多重试 3 次，指数退避策略
- **业务价值**：临时故障自动恢复

**NFR-R9**: 依赖服务故障降级  
- **测量方式**：外部服务（PostgreSQL, Temporal, NATS）故障时系统行为
- **验收标准**：返回明确错误信息，不导致级联崩溃
- **业务价值**：局部故障不影响整体系统

---

### 可扩展性（Scalability）

> **战略重要性**：从 3 个团队到 80% 企业项目的增长路径

#### 水平扩展

**NFR-S1**: 支持无状态水平扩展  
- **测量方式**：增加实例数后系统正常工作
- **验收标准**：核心服务容器可多实例部署，负载均衡生效
- **业务价值**：性能线性提升能力

**NFR-S2**: 10 倍用户增长下性能降级 < 10%  
- **测量方式**：从 3 团队 → 30 团队后的性能对比
- **验收标准**：API 响应时间和事件延迟增加 < 10%
- **业务价值**：长期增长路径保障

**NFR-S3**: 单实例支持 1,000 并发请求  
- **测量方式**：压力测试下的并发处理能力
- **验收标准**：1000 并发请求下响应时间符合 NFR-P3/P4 标准
- **业务价值**：中等规模企业场景支持

#### 数据扩展

**NFR-S4**: 支持百万级数据记录查询  
- **测量方式**：单表数据量达到 100 万条时的查询性能
- **验收标准**：分页查询响应时间仍符合 NFR-P3 标准
- **业务价值**：企业级数据规模支持

**NFR-S5**: 数据库连接池动态调整  
- **测量方式**：负载变化时连接池自动扩缩容
- **验收标准**：最小 5 连接，最大 100 连接，根据负载自动调整
- **业务价值**：资源高效利用和扩展

---

### 安全性（Security）

> **战略重要性**：企业级认证和权限管理的基础保障

#### 认证安全

**NFR-SEC1**: JWT 令牌使用 HMAC SHA-256 签名  
- **测量方式**：令牌签名算法验证
- **验收标准**：所有 JWT 令牌使用 HS256 或更强算法
- **业务价值**：防止令牌伪造

**NFR-SEC2**: JWT 令牌默认有效期 ≤ 24 小时  
- **测量方式**：令牌 exp 声明值
- **验收标准**：默认 24 小时，可配置但不超过 7 天
- **业务价值**：减少令牌泄露风险

**NFR-SEC3**: 密码使用 bcrypt 加密存储  
- **测量方式**：数据库中密码字段加密方式
- **验收标准**：bcrypt 算法，cost factor ≥ 10
- **业务价值**：密码泄露后仍需暴力破解

#### 授权安全

**NFR-SEC4**: 所有 API 请求强制认证检查  
- **测量方式**：未携带有效 JWT 的请求被拒绝
- **验收标准**：100% 的保护 API 返回 401 Unauthorized
- **业务价值**：防止未授权访问

**NFR-SEC5**: RBAC 权限检查在每个请求执行  
- **测量方式**：权限不足的请求被拒绝
- **验收标准**：100% 的权限检查生效，返回 403 Forbidden
- **业务价值**：细粒度访问控制

**NFR-SEC6**: 敏感操作需要权限验证  
- **测量方式**：平台管理 API（租户管理、配置更新）权限检查
- **验收标准**：仅管理员角色可访问
- **业务价值**：防止越权操作

#### 数据安全

**NFR-SEC7**: 数据库连接使用加密传输  
- **测量方式**：PostgreSQL 连接配置
- **验收标准**：生产环境强制 SSL/TLS 连接
- **业务价值**：防止数据传输窃听

**NFR-SEC8**: 日志不记录敏感信息  
- **测量方式**：日志内容检查
- **验收标准**：不记录密码、JWT 令牌完整内容、个人敏感信息
- **业务价值**：防止日志泄露导致安全问题

**NFR-SEC9**: API 错误响应不暴露内部实现细节  
- **测量方式**：错误响应内容检查
- **验收标准**：不暴露数据库结构、文件路径、技术栈版本
- **业务价值**：减少攻击面

---

### 可维护性（Maintainability）

> **战略重要性**：2 人小团队约束，必须降低维护成本

#### 代码质量

**NFR-M1**: 代码测试覆盖率 ≥ 70%  
- **测量方式**：单元测试 + 集成测试覆盖率
- **验收标准**：核心模块（认证、网关、数据）≥ 80%，其他模块 ≥ 60%
- **业务价值**：减少回归 Bug，提升重构信心

**NFR-M2**: 关键路径端到端测试覆盖  
- **测量方式**：E2E 测试用例数量
- **验收标准**：至少覆盖 7 个用户旅程的核心路径
- **业务价值**：保证核心功能完整性

**NFR-M3**: 代码审查覆盖率 100%  
- **测量方式**：PR 合并前审查记录
- **验收标准**：所有代码变更经过至少 1 人审查（基于 Vibe Coding）
- **业务价值**：知识共享，减少低级错误

#### 配置管理

**NFR-M4**: 配置热重载无需重启服务  
- **测量方式**：配置文件变更后系统行为
- **验收标准**：数据模型、实时推送、工作流配置支持热重载
- **业务价值**：减少服务中断，快速迭代

**NFR-M5**: 配置文件语法错误提前检测  
- **测量方式**：CLI 验证命令和启动检查
- **验收标准**：YAML 语法错误在启动前发现并提示
- **业务价值**：减少运行时错误

**NFR-M6**: 配置变更可回滚  
- **测量方式**：Git 版本控制 + 配置备份
- **验收标准**：配置文件纳入版本控制，错误配置可快速回滚
- **业务价值**：降低配置变更风险

#### 文档完整性

**NFR-M7**: API 文档自动生成  
- **测量方式**：OpenAPI 规范文档存在性
- **验收标准**：所有自动生成的 API 都有完整文档
- **业务价值**：减少文档维护成本

**NFR-M8**: 架构文档保持更新  
- **测量方式**：文档更新频率
- **验收标准**：重大架构变更 7 天内更新文档
- **业务价值**：新成员快速上手，减少口头传承

---

### 可观测性（Observability）

> **战略重要性**：核心功能特性，问题排查从小时级到分钟级

#### 日志

**NFR-O1**: 所有模块日志统一收集  
- **测量方式**：日志查询 API 可查询所有模块日志
- **验收标准**：100% 模块日志集中存储
- **业务价值**：单一入口问题排查

**NFR-O2**: 日志包含请求追踪 ID  
- **测量方式**：日志条目包含 request_id 字段
- **验收标准**：跨服务调用可通过 request_id 关联
- **业务价值**：分布式请求链路追踪

**NFR-O3**: 日志查询响应时间 < 1 秒  
- **测量方式**：日志查询 API 响应时间
- **验收标准**：时间范围 ≤ 24 小时、结果 ≤ 1000 条的查询 P95 < 1s
- **业务价值**：实时问题排查

**NFR-O4**: 日志保留周期 ≥ 30 天  
- **测量方式**：日志存储策略
- **验收标准**：至少保留 30 天历史日志
- **业务价值**：历史问题回溯

#### 监控指标

**NFR-O5**: 健康检查端点响应时间 < 500ms  
- **测量方式**：/health 端点响应时间
- **验收标准**：P95 < 500ms
- **业务价值**：快速健康状态判断

**NFR-O6**: Prometheus 指标端点暴露核心指标  
- **测量方式**：/metrics 端点指标数量和类型
- **验收标准**：包含 CPU、内存、请求数、错误率、延迟分布
- **业务价值**：标准监控工具集成

**NFR-O7**: 指标采集间隔 ≤ 15 秒  
- **测量方式**：指标更新频率
- **验收标准**：核心指标每 15 秒更新
- **业务价值**：近实时性能监控

#### 告警

**NFR-O8**: 关键指标超阈值告警  
- **测量方式**：告警规则配置和触发
- **验收标准**：内存 > 90%、CPU > 80%、错误率 > 1% 触发告警
- **业务价值**：主动问题发现

**NFR-O9**: 告警通知延迟 < 1 分钟  
- **测量方式**：从阈值触发到通知发送
- **验收标准**：P95 延迟 < 1 分钟
- **业务价值**：及时响应问题

---

### 集成性（Integration）

> **战略重要性**：外部系统协作和扩展能力

#### 数据库集成

**NFR-I1**: 支持 PostgreSQL 10+  
- **测量方式**：数据库版本兼容性测试
- **验收标准**：PostgreSQL 10, 11, 12, 13, 14 版本测试通过
- **业务价值**：灵活的数据库版本选择

**NFR-I2**: 数据库连接失败自动重试  
- **测量方式**：数据库暂时不可用时的系统行为
- **验收标准**：最多重试 3 次，指数退避（1s, 2s, 4s）
- **业务价值**：临时网络抖动自动恢复

#### Temporal 集成

**NFR-I3**: 支持 Temporal 1.18+  
- **测量方式**：Temporal Server 版本兼容性
- **验收标准**：Temporal 1.18 及更高版本测试通过
- **业务价值**：使用最新稳定版 Temporal

**NFR-I4**: Temporal 连接断开自动重连  
- **测量方式**：Temporal Server 重启后客户端行为
- **验收标准**：自动重连，工作流继续执行
- **业务价值**：Temporal 升级不影响 apprun

#### NATS 集成

**NFR-I5**: 支持 NATS 2.9+  
- **测量方式**：NATS Server 版本兼容性
- **验收标准**：NATS 2.9 及更高版本测试通过
- **业务价值**：使用最新稳定版 NATS

**NFR-I6**: NATS 连接断开自动重连  
- **测量方式**：NATS Server 重启后客户端行为
- **验收标准**：自动重连，事件订阅恢复
- **业务价值**：NATS 升级不影响 apprun

#### HTTP 服务集成

**NFR-I7**: 工作流 HTTP 节点超时时间可配置  
- **测量方式**：工作流配置项
- **验收标准**：默认 30 秒，可配置 1-300 秒
- **业务价值**：适应不同外部服务响应时间

**NFR-I8**: HTTP 节点失败自动重试  
- **测量方式**：HTTP 调用失败后的行为
- **验收标准**：网络错误、5xx 错误自动重试（最多 3 次）
- **业务价值**：临时故障自动恢复

---

### 非功能需求总结

**NFR 分布统计**：
- 性能（Performance）：15 个 NFRs
- 可靠性（Reliability）：9 个 NFRs
- 可扩展性（Scalability）：5 个 NFRs
- 安全性（Security）：9 个 NFRs
- 可维护性（Maintainability）：8 个 NFRs
- 可观测性（Observability）：9 个 NFRs
- 集成性（Integration）：8 个 NFRs

**总计**：63 个非功能需求

**跳过的类别及理由**：
- ❌ 可访问性（Accessibility）：MVP 阶段无前端 UI，纯后端 API + CLI
- ❌ 合规性（Compliance）：无特殊行业要求（GDPR/HIPAA/PCI-DSS）
- ❌ 国际化（Internationalization）：MVP 阶段仅支持中文

**可测试性验证**：
- ✅ 所有 NFRs 包含明确的测量方式
- ✅ 所有 NFRs 包含可验证的验收标准
- ✅ 所有 NFRs 避免模糊术语（如"快速"、"安全"、"可靠"）
- ✅ 所有 NFRs 与业务价值关联

**与功能需求的关系**：
- 功能需求（FRs）定义**能做什么**：90 个能力
- 非功能需求（NFRs）定义**做得多好**：63 个质量标准
- 共同构成 apprun 产品的**完整需求规格**

**战略重要性排序**：
1. ✅ **性能** - 核心竞争力（轻量级目标）
2. ✅ **可靠性** - 企业生产环境基础
3. ✅ **可观测性** - 核心功能特性（集中式日志）
4. ✅ **可维护性** - 小团队约束（2 人开发）
5. ✅ **安全性** - 企业级基础保障
6. ✅ **可扩展性** - 长期增长支持
7. ✅ **集成性** - 外部系统协作
